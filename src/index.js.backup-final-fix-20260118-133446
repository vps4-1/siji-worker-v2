// ==================== 配置区 ====================

const AI_PROVIDERS = {
  OPENROUTER: 'openrouter',
  CLAUDE: 'claude',
  CLAUDE_AGENT: 'claude_agent'
};

const CLAUDE_CONFIG = {
  endpoint: 'https://api.anthropic.com/v1/messages',
  model: 'claude-3-5-sonnet-20241022',
  version: '2023-06-01'
};

const OPENROUTER_CONFIG = {
  endpoint: 'https://openrouter.ai/api/v1/chat/completions',
  models: [
    'anthropic/claude-3.5-sonnet',
    'google/gemini-pro-1.5',
    'deepseek/deepseek-chat',
    'qwen/qwen-2.5-72b-instruct'
  ]
};

const CLAUDE_AGENT_CONFIG = {
  enabled: false,
  endpoint: '',
  features: {
    deepAnalysis: true,
    multiRound: true,
    customPrompts: true
  }
};
// ==================== 去重辅助函数 ====================

function normalizeUrl(url) {
  try {
    const parsed = new URL(url);
    let normalized = `${parsed.protocol}//${parsed.host}${parsed.pathname}`;
    normalized = normalized.toLowerCase().replace(/\/+$/, '');
    return normalized;
  } catch (error) {
    console.error('[URL] 解析失败:', url, error.message);
    return url.toLowerCase();
  }
}

function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}

function generateTitleHash(title) {
  const normalized = title
    .toLowerCase()
    .replace(/[^\w\s\u4e00-\u9fa5]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
  return simpleHash(normalized);
}

/**
 * AI 生成内容指纹
 * 使用 Claude 3.5 提取文章核心关键词，生成内容指纹用于去重
 */
async function generateContentFingerprint(env, article) {
  try {
    const prompt = `Extract 3-5 core topic keywords from this article. Return ONLY comma-separated keywords in English, lowercase, no extra text.

Title: ${article.title}
Summary: ${article.summary ? article.summary?.substring ? article.summary.substring(0, 300) : (article.summary?.content || article.summary || "").substring(0, 300) : article.title}

Keywords:`;

    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': 'https://sijigpt.com',
        'X-Title': 'SiJiGPT'
      },
      body: JSON.stringify({
        model: 'anthropic/claude-3.5-sonnet',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 50,
        temperature: 0.3
      })
    });

    if (!response.ok) {
      throw new Error(`OpenRouter API 错误: ${response.status}`);
    }

    const data = await response.json();
    const keywords = data.choices[0].message.content.trim().toLowerCase();
    
    // 排序关键词生成指纹
    const sorted = keywords.split(',')
      .map(k => k.trim())
      .filter(k => k.length > 0)
      .sort()
      .join('-');
    
    return simpleHash(sorted);
  } catch (error) {
    console.error('[Fingerprint] 生成失败:', error.message);
    // 失败时使用标题哈希作为降级方案
    return generateTitleHash(article.title);
  }
}

/**
 * 三层去重检查
 * 第一层：URL 精确匹配
 * 第二层：标题相似度匹配
 * 第三层：内容指纹匹配（AI 辅助）
 */

/**
 * 截断标题，超出长度显示省略号
 * @param {string} title - 原标题
 * @param {number} maxLength - 最大长度（中文按2字符，英文按1字符计算）
 * @returns {string} 截断后的标题
 */
function truncateTitle(title, maxLength = 60) {
  if (!title) return '';
  
  let length = 0;
  let result = '';
  
  // 遍历每个字符
  for (const char of title) {
    // 中文、日文、韩文字符算 2 个长度，英文等其他字符算 1 个长度
    const charLength = /[\u4e00-\u9fa5\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af]/.test(char) ? 2 : 1;
    
    // 如果加上当前字符会超出长度限制，则停止并添加省略号
    if (length + charLength > maxLength) {
      return result.trim() + '...';
    }
    
    result += char;
    length += charLength;
  }
  
  return result;
}



async function checkDuplicates(env, article, logs) {
  const normalizedUrl = normalizeUrl(article.link);
  const titleHash = generateTitleHash(article.title);
  
  // 第一层：URL 精确去重
  const urlKey = `url:${normalizedUrl}`;
  const urlExists = await env.ARTICLES_KV.get(urlKey);
  if (urlExists) {
    logs.push(`[去重] ⏭️ URL 已存在: ${article.link}`);
    return true;
  }
  
  // 第二层：标题相似度去重
  const titleKey = `title:${titleHash}`;
  const titleExists = await env.ARTICLES_KV.get(titleKey);
  if (titleExists) {
    logs.push(`[去重] ⏭️ 相似标题已存在: ${article.title}`);
    return true;
  }
  
  // 第三层：内容指纹去重（AI 辅助）
  const fingerprint = await generateContentFingerprint(env, article);
  const fpKey = `fp:${fingerprint}`;
  const fpExists = await env.ARTICLES_KV.get(fpKey);
  if (fpExists) {
    logs.push(`[去重] ⏭️ 相似内容已存在: ${article.title}`);
    return true;
  }
  
  return false;
}

/**
 * 保存去重记录
 * 同时保存 URL、标题哈希、内容指纹三个键
 * TTL 设置为 30 天
 */
async function saveDuplicateKeys(env, article) {
  const normalizedUrl = normalizeUrl(article.link);
  const titleHash = generateTitleHash(article.title);
  const fingerprint = await generateContentFingerprint(env, article);
  
  const ttl = 2592000; // 30 天
  const timestamp = new Date().toISOString();
  
  // 保存三个去重键
  await env.ARTICLES_KV.put(`url:${normalizedUrl}`, JSON.stringify({
    publishedAt: timestamp,
    title: article.title
  }), { expirationTtl: ttl });
  
  await env.ARTICLES_KV.put(`title:${titleHash}`, JSON.stringify({
    publishedAt: timestamp,
    title: article.title
  }), { expirationTtl: ttl });
  
  await env.ARTICLES_KV.put(`fp:${fingerprint}`, JSON.stringify({
    publishedAt: timestamp,
    title: article.title
  }), { expirationTtl: ttl });
}

/**
 * 从 URL 提取来源名称
 * 例如：https://openai.com/blog/article → OpenAI Blog
 */
function extractSourceName(url) {
  try {
    const parsed = new URL(url);
    const hostname = parsed.hostname.replace("www.", "");
    
    const sourceMap = {
      "openai.com": "OpenAI Blog",
      "anthropic.com": "Anthropic News",
      "blog.google": "Google AI Blog",
      "deepmind.com": "DeepMind Blog",
      "deepmind.google": "DeepMind Blog",
      "ai.meta.com": "Meta AI Blog",
      "microsoft.com": "Microsoft Research",
      "huggingface.co": "Hugging Face Blog",
      "aws.amazon.com": "AWS Machine Learning Blog",
      "blog.langchain.dev": "LangChain Blog",
      "lilianweng.github.io": "Lil'Log",
      "karpathy.github.io": "Andrej Karpathy Blog",
      "distill.pub": "Distill",
      "arxiv.org": "arXiv",
      "news.ycombinator.com": "Hacker News"
    };
    
    for (const [domain, name] of Object.entries(sourceMap)) {
      if (hostname.includes(domain)) {
        return name;
      }
    }
    
    return hostname.split(".")[0].charAt(0).toUpperCase() + hostname.split(".")[0].slice(1);
  } catch (error) {
    return "Unknown Source";
  }
}

// ==================== 主入口 ====================

export default {
  async scheduled(event, env, ctx) {
    console.log('[定时任务] 触发时间:', new Date().toISOString());
    try {
      const result = await aggregateArticles(env);
      console.log('[定时任务] 完成:', JSON.stringify(result));
    } catch (error) {
      console.error('[定时任务] 错误:', error);
    }
  },

  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;

    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization'
        }
      });
    }

    if (path === '/health' || path === '/') {
      return new Response(JSON.stringify({
        status: 'ok',
        service: 'Siji Worker V2',
        provider: env.AI_PROVIDER || 'openrouter',
        timestamp: new Date().toISOString(),
        version: '2.0.1'
      }), {
        headers: { 
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*'
        }
      });
    }

    if (path === '/test' && request.method === 'POST') {
      try {
        const result = await aggregateArticles(env);
        return new Response(JSON.stringify(result), {
          headers: { 
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
          }
        });
      } catch (error) {
        return new Response(JSON.stringify({ 
          error: error.message,
          stack: error.stack 
        }), {
          status: 500,
          headers: { 
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
          }
        });
      }
    }

    return new Response('Siji Worker V2 Running', { 
      status: 404,
      headers: { 'Access-Control-Allow-Origin': '*' }
    });
  }
};

// ==================== 核心聚合逻辑 ====================

async function aggregateArticles(env) {
  const logs = [];
  let count = 0;
  let published = 0;
  const publishedArticles = [];
  
  const rssFeeds = (env.RSS_FEEDS || '').split(',')
    .map(s => s.trim())
    .filter(Boolean)
    .slice(0, 15);
  
  const dailyTarget = parseInt(env.DAILY_TARGET || '20', 10);
  
  logs.push(`[开始] 目标: ${dailyTarget} 篇, RSS 源: ${rssFeeds.length} 个`);
  logs.push(`[AI] 使用: ${env.AI_PROVIDER || 'openrouter'}`);

  for (const feedUrl of rssFeeds) {
    if (published >= dailyTarget) {
      logs.push(`[完成] 已达目标 ${dailyTarget} 篇，停止抓取`);
      break;
    }
    
    logs.push(`[RSS] 抓取: ${feedUrl}`);
    
    try {
      const response = await fetch(feedUrl, { 
        signal: AbortSignal.timeout(10000),
        headers: { 'User-Agent': 'Siji-Worker/2.0' }
      });
      
      if (!response.ok) {
        logs.push(`[RSS] ❌ HTTP ${response.status}`);
        continue;
      }
      
      const xmlText = await response.text();
      
      const itemMatch = xmlText.match(/<item[^>]*>([\s\S]*?)<\/item>/i);
      if (!itemMatch) {
        logs.push(`[RSS] ⚠️ 未找到文章`);
        continue;
      }
      
      const itemContent = itemMatch[1];
      const title = extractTag(itemContent, 'title');
      const link = extractTag(itemContent, 'link');
      const description = extractTag(itemContent, 'description');
      
      if (!title || !link) {
        logs.push(`[RSS] ⚠️ 文章信息不完整`);
        continue;
      }
      
      count++;
      logs.push(`[RSS] 找到: ${title.substring(0, 50)}...`);
      
      
      // 三层去重检查
      const article = { link, title, summary: description };
      const isDuplicate = await checkDuplicates(env, article, logs);
      if (isDuplicate) {
        continue;
      }
      
      // AI 判定与双语内容生成
      const aiData = await callAI(env, title, description);
      
      if (!aiData || !aiData.relevant) {
        logs.push(`[AI] ⏭️ 不相关`);
        continue;
      }
      
      // 新的数据结构：AI 已返回完整双语内容
      const originalLang = aiData.original_language || "en";
      logs.push(`[AI] ✅ 相关, 原文语言: ${originalLang}`);
      logs.push(`[内容] 中文摘要: ${aiData.summary_zh.length} 字, 英文摘要: ${aiData.summary_en.length} 字`);
      
      // 确定最终标题（始终使用中文标题）
      const finalTitle = aiData.title_zh;
      const finalTitleEn = aiData.title_en;
      
      // 构建双语内容（按需求 2 的格式）
    // ============================================
      // 构建双语内容（HTML 格式，解决星号显示问题）
      // ============================================
      
      // ============================================
      // 构建双语内容（简化来源格式，完整标题自动换行）
      // ============================================
      
      // 准备原文标题数据
      const fullTitle = finalTitleEn || finalTitle; // 完整原文标题
      
      // 构建 HTML 格式的双语内容
      const bilingualContent = `
<p><strong>来源：</strong><a href="${link}" target="_blank" rel="noopener noreferrer">${fullTitle}</a></p>

---

<h2><strong>中文摘要</strong></h2>

${aiData.summary_zh}

<p><strong>关键词：</strong>${(aiData.keywords_zh || []).join("、")}</p>

---

<h2><strong>English Summary</strong></h2>

<p><strong>${finalTitleEn}</strong></p>

${aiData.summary_en}

<p><strong>Keywords:</strong> ${(aiData.keywords_en || []).join(", ")}</p>
`.trim();
      // 构建 Payload 数据对象
      const payloadData = {
        title: finalTitle,
        title_en: finalTitleEn,
        source: {
          url: link,
          name: extractSourceName(link)
        },
        summary_zh: {
          content: aiData.summary_zh,
          keywords: (aiData.keywords_zh || []).map(kw => ({ keyword: kw }))
        },
        summary_en: {
          content: aiData.summary_en,
          keywords: (aiData.keywords_en || []).map(kw => ({ keyword: kw }))
        },
        original_language: aiData.original_language || 'en',
        content: bilingualContent
      };

      const payloadSuccess = await publishToPayload(env, payloadData, logs);
      
      if (!payloadSuccess) {
        logs.push(`[Payload] ❌ 发布失败`);
        continue;
      }
      
      // 发送 Telegram 通知
      await sendBilingualToTelegram(env, {
        title: finalTitle,
        url: link,
        summary: aiData.summary_zh,
        translation: aiData.summary_en,
        language: originalLang
      }, logs);
      
      // 保存三层去重记录（30天 TTL）
      await saveDuplicateKeys(env, {
        link,
        title: finalTitle,
        summary: aiData.summary
      });
      
      published++;
      publishedArticles.push({ title: finalTitle, url: link });
      logs.push(`[发布] ✅ 成功 (${published}/${dailyTarget})`);
      
    } catch (error) {
      logs.push(`[错误] ${feedUrl}: ${error.message}`);
    }
  }
  
  logs.push(`[完成] 处理: ${count}, 发布: ${published}`);
  
  if (published > 0) {
    await sendSummaryToTelegram(env, publishedArticles, logs);
  }
  
  if (published > 0 && env.DEPLOY_HOOK_URL) {
    logs.push(`[Hugo] 触发部署...`);
    try {
      const deployResponse = await fetch(env.DEPLOY_HOOK_URL, { 
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (deployResponse.ok) {
        logs.push(`[Hugo] ✅ 部署已触发`);
      } else {
        logs.push(`[Hugo] ⚠️ 部署触发失败: ${deployResponse.status}`);
      }
    } catch (error) {
      logs.push(`[Hugo] ❌ 部署错误: ${error.message}`);
    }
  }
  
  return { 
    count, 
    published, 
    provider: env.AI_PROVIDER || 'openrouter', 
    logs 
  };
}

// ==================== AI 调用 ====================

function getAIProvider(env) {
  const provider = (env.AI_PROVIDER || 'openrouter').toLowerCase();
  
  if (provider === 'claude' && env.CLAUDE_API_KEY) {
    return AI_PROVIDERS.CLAUDE;
  }
  
  if (provider === 'claude_agent' && CLAUDE_AGENT_CONFIG.enabled) {
    return AI_PROVIDERS.CLAUDE_AGENT;
  }
  
  return AI_PROVIDERS.OPENROUTER;
}

async function callAI(env, title, description) {
  const provider = getAIProvider(env);
  
  try {
    if (provider === AI_PROVIDERS.CLAUDE) {
      return await callClaudeAI(env, title, description);
    } else if (provider === AI_PROVIDERS.CLAUDE_AGENT) {
      return await callClaudeAgent(env, title, description);
    } else {
      return await callOpenRouterAI(env, title, description);
    }
  } catch (error) {
    console.error(`[AI] ${provider} 失败:`, error);
    
    if (provider === AI_PROVIDERS.CLAUDE && env.OPENROUTER_API_KEY) {
      console.log('[AI] 回退到 OpenRouter');
      try {
        return await callOpenRouterAI(env, title, description);
      } catch (fallbackError) {
        console.error('[AI] OpenRouter 回退失败:', fallbackError);
      }
    }
    
    return null;
  }
}

async function callClaudeAI(env, title, description) {
  const prompt = `判断以下内容是否与人工智能领域相关。

标题: ${title}
描述: ${description}

相关范围包括但不限于:
- AI/ML/DL 技术: 机器学习、深度学习、大语言模型、计算机视觉、NLP、强化学习
- AI 应用: ChatGPT、Gemini、Claude、Stable Diffusion、Midjourney、视频生成(Sora/Veo)
- AI 硬件: GPU、TPU、NPU、AI 芯片、算力、数据中心
- AI 平台/工具: TensorFlow、PyTorch、Hugging Face、LangChain、向量数据库
- AI 公司动态: OpenAI、Google DeepMind、Anthropic、Meta AI、NVIDIA、微软、亚马逊等的 AI 相关发布
- AI 研究: 论文、模型架构、训练方法、评测基准
- AI 伦理/安全: AI 对齐、安全性、监管政策

要求:
1. 如果相关,请生成约300字的中文摘要,保留关键信息和技术要点
2. 如果完全不相关(如纯粹的政治、体育、娱乐新闻),返回 relevant: false
3. 提取3-5个关键词

**重要**: 必须严格返回纯 JSON,不要有其他文字:
{
  "relevant": true,
  "summary": "约300字的中文摘要",
  "keywords": ["关键词1", "关键词2", "关键词3"]
}`;

  const response = await fetch(CLAUDE_CONFIG.endpoint, {
    method: 'POST',
    headers: {
      'x-api-key': env.CLAUDE_API_KEY,
      'anthropic-version': CLAUDE_CONFIG.version,
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      model: CLAUDE_CONFIG.model,
      max_tokens: 1024,
      temperature: 0.3,
      messages: [{ role: 'user', content: prompt }]
    })
  });

  if (!response.ok) {
    throw new Error(`Claude API error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.content[0]?.text;
  
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Invalid JSON in Claude response');
  }

  return JSON.parse(jsonMatch[0]);
}

async function callOpenRouterAI(env, title, description) {
  const prompt = `判断以下内容是否与人工智能领域相关，并生成完整的双语摘要。

标题: ${title}
描述: ${description}

相关范围包括但不限于:
- AI/ML/DL 技术: 机器学习、深度学习、大语言模型、计算机视觉、NLP、强化学习
- AI 应用: ChatGPT、Gemini、Claude、Stable Diffusion、Midjourney、视频生成(Sora/Veo)
- AI 硬件: GPU、TPU、NPU、AI 芯片、算力、数据中心
- AI 平台/工具: TensorFlow、PyTorch、Hugging Face、LangChain、向量数据库
- AI 公司动态: OpenAI、Google DeepMind、Anthropic、Meta AI、NVIDIA、微软、亚马逊等的 AI 相关发布
- AI 研究: 论文、模型架构、训练方法、评测基准
- AI 伦理/安全: AI 对齐、安全性、监管政策

要求:
1. 检测原文语言（中文或英文）
2. 如果原文是英文：生成中文标题、中文摘要（300字）、英文摘要（300字）
3. 如果原文是中文：保持中文标题、生成中文摘要（300字）、翻译英文标题和英文摘要（300字）
4. 提取 3-5 个中文关键词和 3-5 个英文关键词
5. 如果完全不相关，返回 relevant: false

**重要**: 必须严格返回纯 JSON:
{
  "relevant": true,
  "original_language": "en",
  "title_zh": "中文标题",
  "title_en": "English Title",
  "summary_zh": "约300字的中文摘要",
  "summary_en": "Approximately 300-word English summary",
  "keywords_zh": ["关键词1", "关键词2", "关键词3"],
  "keywords_en": ["keyword1", "keyword2", "keyword3"]
}`;

  const models = OPENROUTER_CONFIG.models || ['anthropic/claude-3.5-sonnet'];
  
  for (let i = 0; i < models.length; i++) {
    const model = models[i];
    try {
      console.log(`[AI] 尝试模型 ${i + 1}/${models.length}: ${model}`);
      
      const response = await fetch(OPENROUTER_CONFIG.endpoint, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${env.OPENROUTER_API_KEY}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'https://sijigpt.com',
          'X-Title': 'SijiGPT'
        },
        body: JSON.stringify({
          model: model,
          messages: [{ role: 'user', content: prompt }],
          temperature: 0.3,
          max_tokens: 1500
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[AI] 模型 ${model} 失败 ${response.status}:`, errorText.substring(0, 100));
        if (i < models.length - 1) {
          console.log(`[AI] ⏭️ 切换到下一个模型...`);
          continue;
        }
        throw new Error(`所有模型都失败了`);
      }

      const data = await response.json();
      const content = data.choices?.[0]?.message?.content;
      
      if (!content) {
        console.error(`[AI] 模型 ${model} 返回空内容`);
        if (i < models.length - 1) continue;
        throw new Error('AI返回空内容');
      }

      const cleanedContent = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      const result = JSON.parse(cleanedContent);
      
      console.log(`[AI] ✅ 模型 ${model} 成功`);
      return result;

    } catch (error) {
      console.error(`[AI] 模型 ${model} 错误:`, error.message);
      if (i < models.length - 1) {
        console.log(`[AI] ⏭️ 切换到下一个模型...`);
        continue;
      }
      throw error;
    }
  }
}


async function callClaudeAgent(env, title, description) {
  console.log('[AI] Claude Agent 暂未启用，回退到 OpenRouter');
  return await callOpenRouterAI(env, title, description);
}

// ==================== 翻译函数 ====================

async function translateText(env, text, title, fromLang) {
  const provider = getAIProvider(env);
  
  try {
    if (provider === AI_PROVIDERS.CLAUDE) {
      return await translateWithClaude(env, text, title, fromLang);
    } else {
      return await translateWithOpenRouter(env, text, title, fromLang);
    }
  } catch (error) {
    console.error(`[翻译] ${provider} 失败:`, error);
    
    if (provider === AI_PROVIDERS.CLAUDE && env.OPENROUTER_API_KEY) {
      console.log('[翻译] 回退到 OpenRouter');
      try {
        return await translateWithOpenRouter(env, text, title, fromLang);
      } catch (fallbackError) {
        console.error('[翻译] OpenRouter 回退失败:', fallbackError);
      }
    }
    
    return null;
  }
}

async function translateWithClaude(env, text, title, fromLang) {
  const toLang = fromLang === 'zh' ? 'English' : '中文';
  const prompt = `请将以下内容翻译成${toLang}，保留约300字长度：

标题: ${title}
内容: ${text}

返回纯 JSON 格式:
{
  "title": "翻译后的标题",
  "content": "翻译后的内容（约300字）"
}`;

  const response = await fetch(CLAUDE_CONFIG.endpoint, {
    method: 'POST',
    headers: {
      'x-api-key': env.CLAUDE_API_KEY,
      'anthropic-version': CLAUDE_CONFIG.version,
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      model: CLAUDE_CONFIG.model,
      max_tokens: 1024,
      temperature: 0.3,
      messages: [{ role: 'user', content: prompt }]
    })
  });

  if (!response.ok) {
    throw new Error(`Claude translation error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.content[0]?.text;
  
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Invalid JSON');
  }

  return JSON.parse(jsonMatch[0]);
}

async function translateWithOpenRouter(env, text, title, fromLang) {
  const toLang = fromLang === 'zh' ? 'English' : '中文';
  const prompt = `请将以下内容翻译成${toLang}，保留约300字长度：

标题: ${title}
内容: ${text}

返回纯 JSON 格式:
{
  "title": "翻译后的标题",
  "content": "翻译后的内容（约300字）"
}`;

  try {
    const response = await fetch(OPENROUTER_CONFIG.endpoint, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': 'https://siji-weekly.pages.dev',
        'X-Title': 'Siji Weekly'
      },
      body: JSON.stringify({
        model: OPENROUTER_CONFIG.model,
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3,
        max_tokens: 1000
      })
    });

    if (!response.ok) {
      throw new Error(`OpenRouter translation error: ${response.status}`);
    }

    const responseText = await response.text();
    const data = JSON.parse(responseText);
    const content = data.choices[0]?.message?.content;
    
    let jsonMatch = content.match(/```json\s*(\{[\s\S]*?\})\s*```/);
    if (!jsonMatch) {
      jsonMatch = content.match(/\{[\s\S]*\}/);
    }
    
    if (!jsonMatch) {
      throw new Error('Invalid JSON in translation');
    }

    return JSON.parse(jsonMatch[1] || jsonMatch[0]);

  } catch (error) {
    console.error('[翻译] OpenRouter 错误:', error);
    throw error;
  }
}

// ==================== Payload 发布 (修复版) ====================

async function publishToPayload(env, article, logs) {
  // 步骤 1: 先登录获取 Token
  let token = env.PAYLOAD_TOKEN;
  
  if (!token) {
    if (!env.PAYLOAD_EMAIL || !env.PAYLOAD_PASSWORD) {
      logs.push('[Payload] ❌ 未配置认证信息 (需要 PAYLOAD_TOKEN 或 PAYLOAD_EMAIL + PAYLOAD_PASSWORD)');
      return false;
    }
    
    try {
      logs.push('[Payload] 开始登录...');
      const loginResponse = await fetch('https://payload-website-starter-blush-sigma.vercel.app/api/users/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: env.PAYLOAD_EMAIL,
          password: env.PAYLOAD_PASSWORD
        })
      });
      
      if (!loginResponse.ok) {
        const errorText = await loginResponse.text();
        logs.push(`[Payload] ❌ 登录失败: ${errorText}`);
        return false;
      }
      
      const loginData = await loginResponse.json();
      token = loginData.token;
      logs.push('[Payload] ✅ 登录成功');
    } catch (error) {
      logs.push(`[Payload] ❌ 登录错误: ${error.message}`);
      return false;
    }
  } else {
    logs.push('[Payload] 使用已配置的 Token');
  }
  
  // 步骤 2: 发布文章
  try {
    // 使用传入的 article 对象（已经包含正确的嵌套结构）
    const payloadData = {
      ...article,
      slug: generateSlug(article.title),
      publishedAt: new Date().toISOString(),
      _status: "published"
    };
    
    const response = await fetch('https://payload-website-starter-blush-sigma.vercel.app/api/posts', {
      method: 'POST',
      headers: {
        'Authorization': `JWT ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payloadData)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      logs.push(`[Payload] ❌ 发布失败: ${errorText}`);
      return false;
    }
    
    const result = await response.json();
    logs.push(`[Payload] ✅ 发布成功 ID: ${result.doc.id}`);
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: env.TELEGRAM_CHANNEL,
        text: message,
        parse_mode: 'Markdown'
      })
    });

    if (response.ok) {
      logs.push(`[Telegram] ✅ 汇总已发送`);
    }
  } catch (error) {
    logs.push(`[Telegram] ❌ 汇总发送失败: ${error.message}`);
  }
}

// ==================== 工具函数 ====================

function extractTag(xml, tagName) {
  const match = xml.match(new RegExp(`<${tagName}[^>]*>([\\s\\S]*?)<\\/${tagName}>`, 'i'));
  if (!match) return '';
  
  let content = match[1].trim();
  content = content.replace(/<!\[CDATA\[([\s\S]*?)\]\]>/g, '$1');
  content = content.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
  content = content.replace(/<[^>]+>/g, '');
  
  return content;
}

function detectLanguage(text) {
  const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
  const totalChars = text.length;
  return (chineseChars / totalChars) > 0.3 ? 'zh' : 'en';
}

function generateSlug(title) {
  // 生成基础 slug
  const baseSlug = title
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .substring(0, 40);
  
  // 添加时间戳后缀避免重复
  const timestamp = Date.now().toString(36);
  
  return `${baseSlug}-${timestamp}`;
}