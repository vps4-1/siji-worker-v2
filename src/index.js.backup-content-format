// ==================== é…ç½®åŒº ====================

const AI_PROVIDERS = {
  OPENROUTER: 'openrouter',
  CLAUDE: 'claude',
  CLAUDE_AGENT: 'claude_agent'
};

const CLAUDE_CONFIG = {
  endpoint: 'https://api.anthropic.com/v1/messages',
  model: 'claude-3-5-sonnet-20241022',
  version: '2023-06-01'
};

const OPENROUTER_CONFIG = {
  endpoint: 'https://openrouter.ai/api/v1/chat/completions',
  model: 'anthropic/claude-3.5-sonnet'
};

const CLAUDE_AGENT_CONFIG = {
  enabled: false,
  endpoint: '',
  features: {
    deepAnalysis: true,
    multiRound: true,
    customPrompts: true
  }
};
// ==================== å»é‡è¾…åŠ©å‡½æ•° ====================

function normalizeUrl(url) {
  try {
    const parsed = new URL(url);
    let normalized = `${parsed.protocol}//${parsed.host}${parsed.pathname}`;
    normalized = normalized.toLowerCase().replace(/\/+$/, '');
    return normalized;
  } catch (error) {
    console.error('[URL] è§£æå¤±è´¥:', url, error.message);
    return url.toLowerCase();
  }
}

function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}

function generateTitleHash(title) {
  const normalized = title
    .toLowerCase()
    .replace(/[^\w\s\u4e00-\u9fa5]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
  return simpleHash(normalized);
}

/**
 * AI ç”Ÿæˆå†…å®¹æŒ‡çº¹
 * ä½¿ç”¨ Claude 3.5 æå–æ–‡ç« æ ¸å¿ƒå…³é”®è¯ï¼Œç”Ÿæˆå†…å®¹æŒ‡çº¹ç”¨äºå»é‡
 */
async function generateContentFingerprint(env, article) {
  try {
    const prompt = `Extract 3-5 core topic keywords from this article. Return ONLY comma-separated keywords in English, lowercase, no extra text.

Title: ${article.title}
Summary: ${article.summary ? article.summary.substring(0, 300) : article.title}

Keywords:`;

    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': 'https://sijigpt.com',
        'X-Title': 'SiJiGPT'
      },
      body: JSON.stringify({
        model: 'anthropic/claude-3.5-sonnet',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 50,
        temperature: 0.3
      })
    });

    if (!response.ok) {
      throw new Error(`OpenRouter API é”™è¯¯: ${response.status}`);
    }

    const data = await response.json();
    const keywords = data.choices[0].message.content.trim().toLowerCase();
    
    // æ’åºå…³é”®è¯ç”ŸæˆæŒ‡çº¹
    const sorted = keywords.split(',')
      .map(k => k.trim())
      .filter(k => k.length > 0)
      .sort()
      .join('-');
    
    return simpleHash(sorted);
  } catch (error) {
    console.error('[Fingerprint] ç”Ÿæˆå¤±è´¥:', error.message);
    // å¤±è´¥æ—¶ä½¿ç”¨æ ‡é¢˜å“ˆå¸Œä½œä¸ºé™çº§æ–¹æ¡ˆ
    return generateTitleHash(article.title);
  }
}

/**
 * ä¸‰å±‚å»é‡æ£€æŸ¥
 * ç¬¬ä¸€å±‚ï¼šURL ç²¾ç¡®åŒ¹é…
 * ç¬¬äºŒå±‚ï¼šæ ‡é¢˜ç›¸ä¼¼åº¦åŒ¹é…
 * ç¬¬ä¸‰å±‚ï¼šå†…å®¹æŒ‡çº¹åŒ¹é…ï¼ˆAI è¾…åŠ©ï¼‰
 */
async function checkDuplicates(env, article, logs) {
  const normalizedUrl = normalizeUrl(article.link);
  const titleHash = generateTitleHash(article.title);
  
  // ç¬¬ä¸€å±‚ï¼šURL ç²¾ç¡®å»é‡
  const urlKey = `url:${normalizedUrl}`;
  const urlExists = await env.ARTICLES_KV.get(urlKey);
  if (urlExists) {
    logs.push(`[å»é‡] â­ï¸ URL å·²å­˜åœ¨: ${article.link}`);
    return true;
  }
  
  // ç¬¬äºŒå±‚ï¼šæ ‡é¢˜ç›¸ä¼¼åº¦å»é‡
  const titleKey = `title:${titleHash}`;
  const titleExists = await env.ARTICLES_KV.get(titleKey);
  if (titleExists) {
    logs.push(`[å»é‡] â­ï¸ ç›¸ä¼¼æ ‡é¢˜å·²å­˜åœ¨: ${article.title}`);
    return true;
  }
  
  // ç¬¬ä¸‰å±‚ï¼šå†…å®¹æŒ‡çº¹å»é‡ï¼ˆAI è¾…åŠ©ï¼‰
  const fingerprint = await generateContentFingerprint(env, article);
  const fpKey = `fp:${fingerprint}`;
  const fpExists = await env.ARTICLES_KV.get(fpKey);
  if (fpExists) {
    logs.push(`[å»é‡] â­ï¸ ç›¸ä¼¼å†…å®¹å·²å­˜åœ¨: ${article.title}`);
    return true;
  }
  
  return false;
}

/**
 * ä¿å­˜å»é‡è®°å½•
 * åŒæ—¶ä¿å­˜ URLã€æ ‡é¢˜å“ˆå¸Œã€å†…å®¹æŒ‡çº¹ä¸‰ä¸ªé”®
 * TTL è®¾ç½®ä¸º 30 å¤©
 */
async function saveDuplicateKeys(env, article) {
  const normalizedUrl = normalizeUrl(article.link);
  const titleHash = generateTitleHash(article.title);
  const fingerprint = await generateContentFingerprint(env, article);
  
  const ttl = 2592000; // 30 å¤©
  const timestamp = new Date().toISOString();
  
  // ä¿å­˜ä¸‰ä¸ªå»é‡é”®
  await env.ARTICLES_KV.put(`url:${normalizedUrl}`, JSON.stringify({
    publishedAt: timestamp,
    title: article.title
  }), { expirationTtl: ttl });
  
  await env.ARTICLES_KV.put(`title:${titleHash}`, JSON.stringify({
    publishedAt: timestamp,
    title: article.title
  }), { expirationTtl: ttl });
  
  await env.ARTICLES_KV.put(`fp:${fingerprint}`, JSON.stringify({
    publishedAt: timestamp,
    title: article.title
  }), { expirationTtl: ttl });
}

// ==================== ä¸»å…¥å£ ====================

export default {
  async scheduled(event, env, ctx) {
    console.log('[å®šæ—¶ä»»åŠ¡] è§¦å‘æ—¶é—´:', new Date().toISOString());
    try {
      const result = await aggregateArticles(env);
      console.log('[å®šæ—¶ä»»åŠ¡] å®Œæˆ:', JSON.stringify(result));
    } catch (error) {
      console.error('[å®šæ—¶ä»»åŠ¡] é”™è¯¯:', error);
    }
  },

  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;

    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization'
        }
      });
    }

    if (path === '/health' || path === '/') {
      return new Response(JSON.stringify({
        status: 'ok',
        service: 'Siji Worker V2',
        provider: env.AI_PROVIDER || 'openrouter',
        timestamp: new Date().toISOString(),
        version: '2.0.1'
      }), {
        headers: { 
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*'
        }
      });
    }

    if (path === '/test' && request.method === 'POST') {
      try {
        const result = await aggregateArticles(env);
        return new Response(JSON.stringify(result), {
          headers: { 
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
          }
        });
      } catch (error) {
        return new Response(JSON.stringify({ 
          error: error.message,
          stack: error.stack 
        }), {
          status: 500,
          headers: { 
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
          }
        });
      }
    }

    return new Response('Siji Worker V2 Running', { 
      status: 404,
      headers: { 'Access-Control-Allow-Origin': '*' }
    });
  }
};

// ==================== æ ¸å¿ƒèšåˆé€»è¾‘ ====================

async function aggregateArticles(env) {
  const logs = [];
  let count = 0;
  let published = 0;
  const publishedArticles = [];
  
  const rssFeeds = (env.RSS_FEEDS || '').split(',')
    .map(s => s.trim())
    .filter(Boolean)
    .slice(0, 15);
  
  const dailyTarget = parseInt(env.DAILY_TARGET || '20', 10);
  
  logs.push(`[å¼€å§‹] ç›®æ ‡: ${dailyTarget} ç¯‡, RSS æº: ${rssFeeds.length} ä¸ª`);
  logs.push(`[AI] ä½¿ç”¨: ${env.AI_PROVIDER || 'openrouter'}`);

  for (const feedUrl of rssFeeds) {
    if (published >= dailyTarget) {
      logs.push(`[å®Œæˆ] å·²è¾¾ç›®æ ‡ ${dailyTarget} ç¯‡ï¼Œåœæ­¢æŠ“å–`);
      break;
    }
    
    logs.push(`[RSS] æŠ“å–: ${feedUrl}`);
    
    try {
      const response = await fetch(feedUrl, { 
        signal: AbortSignal.timeout(10000),
        headers: { 'User-Agent': 'Siji-Worker/2.0' }
      });
      
      if (!response.ok) {
        logs.push(`[RSS] âŒ HTTP ${response.status}`);
        continue;
      }
      
      const xmlText = await response.text();
      
      const itemMatch = xmlText.match(/<item[^>]*>([\s\S]*?)<\/item>/i);
      if (!itemMatch) {
        logs.push(`[RSS] âš ï¸ æœªæ‰¾åˆ°æ–‡ç« `);
        continue;
      }
      
      const itemContent = itemMatch[1];
      const title = extractTag(itemContent, 'title');
      const link = extractTag(itemContent, 'link');
      const description = extractTag(itemContent, 'description');
      
      if (!title || !link) {
        logs.push(`[RSS] âš ï¸ æ–‡ç« ä¿¡æ¯ä¸å®Œæ•´`);
        continue;
      }
      
      count++;
      logs.push(`[RSS] æ‰¾åˆ°: ${title.substring(0, 50)}...`);
      
      
      // ä¸‰å±‚å»é‡æ£€æŸ¥
      const article = { link, title, summary: description };
      const isDuplicate = await checkDuplicates(env, article, logs);
      if (isDuplicate) {
        continue;
      }
      
      const aiData = await callAI(env, title, description);
      
      if (!aiData || !aiData.relevant) {
        logs.push(`[AI] â­ï¸ ä¸ç›¸å…³`);
        continue;
      }
      
      logs.push(`[AI] âœ… ç›¸å…³, æ‘˜è¦é•¿åº¦: ${aiData.summary.length} å­—`);
      
      const isChineseLang = detectLanguage(aiData.summary) === 'zh';
      logs.push(`[è¯­è¨€] æ£€æµ‹ä¸º: ${isChineseLang ? 'ä¸­æ–‡' : 'è‹±æ–‡'}`);
      
      const truncatedSummary = aiData.summary.substring(0, 300);
      const targetLang = isChineseLang ? 'en' : 'zh';
      const translation = await translateText(env, truncatedSummary, title, isChineseLang ? 'zh' : 'en');
      
      if (!translation || !translation.content) {
        logs.push(`[ç¿»è¯‘] âŒ å¤±è´¥`);
        continue;
      }
      
      logs.push(`[ç¿»è¯‘] âœ… å®Œæˆ: ${targetLang}`);
      
      let bilingualContent;
      let finalTitle;
      
      if (isChineseLang) {
        finalTitle = title;
        bilingualContent = `
## ${title}

**æ¥æº**: [${link}](${link})

**æ‘˜è¦**:
${truncatedSummary}

**å…³é”®è¯**: ${(aiData.keywords || []).join(', ')}

---

## ${translation.title}

${translation.content}
`.trim();
      } else {
        finalTitle = title;
        bilingualContent = `
## ${title}

**Source**: [${link}](${link})

**Summary**:
${truncatedSummary}

**Keywords**: ${(aiData.keywords || []).join(', ')}

---

## ${translation.title}

${translation.content}
`.trim();
      }
      
      const payloadSuccess = await publishToPayload(env, {
        title: finalTitle,
        content: bilingualContent,
        url: link,
        summary: truncatedSummary,
        keywords: aiData.keywords || [],
        language: isChineseLang ? 'zh' : 'en'
      }, logs);
      
      if (!payloadSuccess) {
        logs.push(`[Payload] âŒ å‘å¸ƒå¤±è´¥`);
        continue;
      }
      
      await sendBilingualToTelegram(env, {
        title: finalTitle,
        url: link,
        summary: truncatedSummary.substring(0, 150),
        translation: translation.content.substring(0, 150),
        language: isChineseLang ? 'zh' : 'en'
      }, logs);
      
      
      // ä¿å­˜ä¸‰å±‚å»é‡è®°å½•ï¼ˆ30å¤© TTLï¼‰
      await saveDuplicateKeys(env, {
        link,
        title: finalTitle,
        summary: aiData.summary
      });
      
      published++;
      publishedArticles.push({ title: finalTitle, url: link });
      logs.push(`[å‘å¸ƒ] âœ… æˆåŠŸ (${published}/${dailyTarget})`);
      
    } catch (error) {
      logs.push(`[é”™è¯¯] ${feedUrl}: ${error.message}`);
    }
  }
  
  logs.push(`[å®Œæˆ] å¤„ç†: ${count}, å‘å¸ƒ: ${published}`);
  
  if (published > 0) {
    await sendSummaryToTelegram(env, publishedArticles, logs);
  }
  
  if (published > 0 && env.DEPLOY_HOOK_URL) {
    logs.push(`[Hugo] è§¦å‘éƒ¨ç½²...`);
    try {
      const deployResponse = await fetch(env.DEPLOY_HOOK_URL, { 
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (deployResponse.ok) {
        logs.push(`[Hugo] âœ… éƒ¨ç½²å·²è§¦å‘`);
      } else {
        logs.push(`[Hugo] âš ï¸ éƒ¨ç½²è§¦å‘å¤±è´¥: ${deployResponse.status}`);
      }
    } catch (error) {
      logs.push(`[Hugo] âŒ éƒ¨ç½²é”™è¯¯: ${error.message}`);
    }
  }
  
  return { 
    count, 
    published, 
    provider: env.AI_PROVIDER || 'openrouter', 
    logs 
  };
}

// ==================== AI è°ƒç”¨ ====================

function getAIProvider(env) {
  const provider = (env.AI_PROVIDER || 'openrouter').toLowerCase();
  
  if (provider === 'claude' && env.CLAUDE_API_KEY) {
    return AI_PROVIDERS.CLAUDE;
  }
  
  if (provider === 'claude_agent' && CLAUDE_AGENT_CONFIG.enabled) {
    return AI_PROVIDERS.CLAUDE_AGENT;
  }
  
  return AI_PROVIDERS.OPENROUTER;
}

async function callAI(env, title, description) {
  const provider = getAIProvider(env);
  
  try {
    if (provider === AI_PROVIDERS.CLAUDE) {
      return await callClaudeAI(env, title, description);
    } else if (provider === AI_PROVIDERS.CLAUDE_AGENT) {
      return await callClaudeAgent(env, title, description);
    } else {
      return await callOpenRouterAI(env, title, description);
    }
  } catch (error) {
    console.error(`[AI] ${provider} å¤±è´¥:`, error);
    
    if (provider === AI_PROVIDERS.CLAUDE && env.OPENROUTER_API_KEY) {
      console.log('[AI] å›é€€åˆ° OpenRouter');
      try {
        return await callOpenRouterAI(env, title, description);
      } catch (fallbackError) {
        console.error('[AI] OpenRouter å›é€€å¤±è´¥:', fallbackError);
      }
    }
    
    return null;
  }
}

async function callClaudeAI(env, title, description) {
  const prompt = `åˆ¤æ–­ä»¥ä¸‹å†…å®¹æ˜¯å¦ä¸äººå·¥æ™ºèƒ½é¢†åŸŸç›¸å…³ã€‚

æ ‡é¢˜: ${title}
æè¿°: ${description}

ç›¸å…³èŒƒå›´åŒ…æ‹¬ä½†ä¸é™äº:
- AI/ML/DL æŠ€æœ¯: æœºå™¨å­¦ä¹ ã€æ·±åº¦å­¦ä¹ ã€å¤§è¯­è¨€æ¨¡å‹ã€è®¡ç®—æœºè§†è§‰ã€NLPã€å¼ºåŒ–å­¦ä¹ 
- AI åº”ç”¨: ChatGPTã€Geminiã€Claudeã€Stable Diffusionã€Midjourneyã€è§†é¢‘ç”Ÿæˆ(Sora/Veo)
- AI ç¡¬ä»¶: GPUã€TPUã€NPUã€AI èŠ¯ç‰‡ã€ç®—åŠ›ã€æ•°æ®ä¸­å¿ƒ
- AI å¹³å°/å·¥å…·: TensorFlowã€PyTorchã€Hugging Faceã€LangChainã€å‘é‡æ•°æ®åº“
- AI å…¬å¸åŠ¨æ€: OpenAIã€Google DeepMindã€Anthropicã€Meta AIã€NVIDIAã€å¾®è½¯ã€äºšé©¬é€Šç­‰çš„ AI ç›¸å…³å‘å¸ƒ
- AI ç ”ç©¶: è®ºæ–‡ã€æ¨¡å‹æ¶æ„ã€è®­ç»ƒæ–¹æ³•ã€è¯„æµ‹åŸºå‡†
- AI ä¼¦ç†/å®‰å…¨: AI å¯¹é½ã€å®‰å…¨æ€§ã€ç›‘ç®¡æ”¿ç­–

è¦æ±‚:
1. å¦‚æœç›¸å…³,è¯·ç”Ÿæˆçº¦300å­—çš„ä¸­æ–‡æ‘˜è¦,ä¿ç•™å…³é”®ä¿¡æ¯å’ŒæŠ€æœ¯è¦ç‚¹
2. å¦‚æœå®Œå…¨ä¸ç›¸å…³(å¦‚çº¯ç²¹çš„æ”¿æ²»ã€ä½“è‚²ã€å¨±ä¹æ–°é—»),è¿”å› relevant: false
3. æå–3-5ä¸ªå…³é”®è¯

**é‡è¦**: å¿…é¡»ä¸¥æ ¼è¿”å›çº¯ JSON,ä¸è¦æœ‰å…¶ä»–æ–‡å­—:
{
  "relevant": true,
  "summary": "çº¦300å­—çš„ä¸­æ–‡æ‘˜è¦",
  "keywords": ["å…³é”®è¯1", "å…³é”®è¯2", "å…³é”®è¯3"]
}`;

  const response = await fetch(CLAUDE_CONFIG.endpoint, {
    method: 'POST',
    headers: {
      'x-api-key': env.CLAUDE_API_KEY,
      'anthropic-version': CLAUDE_CONFIG.version,
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      model: CLAUDE_CONFIG.model,
      max_tokens: 1024,
      temperature: 0.3,
      messages: [{ role: 'user', content: prompt }]
    })
  });

  if (!response.ok) {
    throw new Error(`Claude API error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.content[0]?.text;
  
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Invalid JSON in Claude response');
  }

  return JSON.parse(jsonMatch[0]);
}

async function callOpenRouterAI(env, title, description) {
  const prompt = `åˆ¤æ–­ä»¥ä¸‹å†…å®¹æ˜¯å¦ä¸äººå·¥æ™ºèƒ½é¢†åŸŸç›¸å…³ã€‚

æ ‡é¢˜: ${title}
æè¿°: ${description}

ç›¸å…³èŒƒå›´åŒ…æ‹¬ä½†ä¸é™äº:
- AI/ML/DL æŠ€æœ¯: æœºå™¨å­¦ä¹ ã€æ·±åº¦å­¦ä¹ ã€å¤§è¯­è¨€æ¨¡å‹ã€è®¡ç®—æœºè§†è§‰ã€NLPã€å¼ºåŒ–å­¦ä¹ 
- AI åº”ç”¨: ChatGPTã€Geminiã€Claudeã€Stable Diffusionã€Midjourneyã€è§†é¢‘ç”Ÿæˆ(Sora/Veo)
- AI ç¡¬ä»¶: GPUã€TPUã€NPUã€AI èŠ¯ç‰‡ã€ç®—åŠ›ã€æ•°æ®ä¸­å¿ƒ
- AI å¹³å°/å·¥å…·: TensorFlowã€PyTorchã€Hugging Faceã€LangChainã€å‘é‡æ•°æ®åº“
- AI å…¬å¸åŠ¨æ€: OpenAIã€Google DeepMindã€Anthropicã€Meta AIã€NVIDIAã€å¾®è½¯ã€äºšé©¬é€Šç­‰çš„ AI ç›¸å…³å‘å¸ƒ
- AI ç ”ç©¶: è®ºæ–‡ã€æ¨¡å‹æ¶æ„ã€è®­ç»ƒæ–¹æ³•ã€è¯„æµ‹åŸºå‡†
- AI ä¼¦ç†/å®‰å…¨: AI å¯¹é½ã€å®‰å…¨æ€§ã€ç›‘ç®¡æ”¿ç­–

è¦æ±‚:
1. å¦‚æœç›¸å…³,è¯·ç”Ÿæˆçº¦300å­—çš„ä¸­æ–‡æ‘˜è¦,ä¿ç•™å…³é”®ä¿¡æ¯å’ŒæŠ€æœ¯è¦ç‚¹
2. å¦‚æœå®Œå…¨ä¸ç›¸å…³(å¦‚çº¯ç²¹çš„æ”¿æ²»ã€ä½“è‚²ã€å¨±ä¹æ–°é—»),è¿”å› relevant: false
3. æå–3-5ä¸ªå…³é”®è¯

**é‡è¦**: å¿…é¡»ä¸¥æ ¼è¿”å›çº¯ JSON,ä¸è¦æœ‰å…¶ä»–æ–‡å­—:
{
  "relevant": true,
  "summary": "çº¦300å­—çš„ä¸­æ–‡æ‘˜è¦",
  "keywords": ["å…³é”®è¯1", "å…³é”®è¯2", "å…³é”®è¯3"]
}`;

  try {
    const response = await fetch(OPENROUTER_CONFIG.endpoint, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': 'https://siji-weekly.pages.dev',
        'X-Title': 'Siji Weekly'
      },
      body: JSON.stringify({
        model: OPENROUTER_CONFIG.model,
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3,
        max_tokens: 800
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('[OpenRouter] HTTPé”™è¯¯:', response.status, errorText);
      throw new Error(`OpenRouter API error: ${response.status}`);
    }

    // âœ… ä¿®å¤: å…ˆè¯»æ–‡æœ¬å†è§£æ
    const responseText = await response.text();
    console.log('[OpenRouter] åŸå§‹å“åº”:', responseText.substring(0, 300));

    let data;
    try {
      data = JSON.parse(responseText);
    } catch (jsonError) {
      console.error('[OpenRouter] JSONè§£æå¤±è´¥:', responseText);
      throw new Error(`JSON parse error: ${jsonError.message}`);
    }

    if (!data.choices?.[0]?.message?.content) {
      console.error('[OpenRouter] å“åº”ç»“æ„å¼‚å¸¸:', JSON.stringify(data));
      throw new Error('Invalid OpenRouter response structure');
    }

    const content = data.choices[0].message.content;
    
    // âœ… æ”¯æŒå¤šç§ JSON æ ¼å¼
    let jsonMatch = content.match(/```json\s*(\{[\s\S]*?\})\s*```/);
    if (!jsonMatch) {
      jsonMatch = content.match(/\{[\s\S]*\}/);
    }
    
    if (!jsonMatch) {
      console.error('[OpenRouter] æœªæ‰¾åˆ°JSON:', content);
      throw new Error('No JSON found in response');
    }

    const aiResult = JSON.parse(jsonMatch[1] || jsonMatch[0]);
    
    // âœ… éªŒè¯å¿…éœ€å­—æ®µ
    if (typeof aiResult.relevant === 'undefined') {
      console.error('[OpenRouter] ç¼ºå°‘ relevant å­—æ®µ:', aiResult);
      throw new Error('Missing "relevant" field in AI response');
    }

    return aiResult;

  } catch (error) {
    console.error('[OpenRouter] å®Œæ•´é”™è¯¯:', error);
    throw error;
  }
}

async function callClaudeAgent(env, title, description) {
  console.log('[AI] Claude Agent æš‚æœªå¯ç”¨ï¼Œå›é€€åˆ° OpenRouter');
  return await callOpenRouterAI(env, title, description);
}

// ==================== ç¿»è¯‘å‡½æ•° ====================

async function translateText(env, text, title, fromLang) {
  const provider = getAIProvider(env);
  
  try {
    if (provider === AI_PROVIDERS.CLAUDE) {
      return await translateWithClaude(env, text, title, fromLang);
    } else {
      return await translateWithOpenRouter(env, text, title, fromLang);
    }
  } catch (error) {
    console.error(`[ç¿»è¯‘] ${provider} å¤±è´¥:`, error);
    
    if (provider === AI_PROVIDERS.CLAUDE && env.OPENROUTER_API_KEY) {
      console.log('[ç¿»è¯‘] å›é€€åˆ° OpenRouter');
      try {
        return await translateWithOpenRouter(env, text, title, fromLang);
      } catch (fallbackError) {
        console.error('[ç¿»è¯‘] OpenRouter å›é€€å¤±è´¥:', fallbackError);
      }
    }
    
    return null;
  }
}

async function translateWithClaude(env, text, title, fromLang) {
  const toLang = fromLang === 'zh' ? 'English' : 'ä¸­æ–‡';
  const prompt = `è¯·å°†ä»¥ä¸‹å†…å®¹ç¿»è¯‘æˆ${toLang}ï¼Œä¿ç•™çº¦300å­—é•¿åº¦ï¼š

æ ‡é¢˜: ${title}
å†…å®¹: ${text}

è¿”å›çº¯ JSON æ ¼å¼:
{
  "title": "ç¿»è¯‘åçš„æ ‡é¢˜",
  "content": "ç¿»è¯‘åçš„å†…å®¹ï¼ˆçº¦300å­—ï¼‰"
}`;

  const response = await fetch(CLAUDE_CONFIG.endpoint, {
    method: 'POST',
    headers: {
      'x-api-key': env.CLAUDE_API_KEY,
      'anthropic-version': CLAUDE_CONFIG.version,
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      model: CLAUDE_CONFIG.model,
      max_tokens: 1024,
      temperature: 0.3,
      messages: [{ role: 'user', content: prompt }]
    })
  });

  if (!response.ok) {
    throw new Error(`Claude translation error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.content[0]?.text;
  
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Invalid JSON');
  }

  return JSON.parse(jsonMatch[0]);
}

async function translateWithOpenRouter(env, text, title, fromLang) {
  const toLang = fromLang === 'zh' ? 'English' : 'ä¸­æ–‡';
  const prompt = `è¯·å°†ä»¥ä¸‹å†…å®¹ç¿»è¯‘æˆ${toLang}ï¼Œä¿ç•™çº¦300å­—é•¿åº¦ï¼š

æ ‡é¢˜: ${title}
å†…å®¹: ${text}

è¿”å›çº¯ JSON æ ¼å¼:
{
  "title": "ç¿»è¯‘åçš„æ ‡é¢˜",
  "content": "ç¿»è¯‘åçš„å†…å®¹ï¼ˆçº¦300å­—ï¼‰"
}`;

  try {
    const response = await fetch(OPENROUTER_CONFIG.endpoint, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': 'https://siji-weekly.pages.dev',
        'X-Title': 'Siji Weekly'
      },
      body: JSON.stringify({
        model: OPENROUTER_CONFIG.model,
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3,
        max_tokens: 1000
      })
    });

    if (!response.ok) {
      throw new Error(`OpenRouter translation error: ${response.status}`);
    }

    const responseText = await response.text();
    const data = JSON.parse(responseText);
    const content = data.choices[0]?.message?.content;
    
    let jsonMatch = content.match(/```json\s*(\{[\s\S]*?\})\s*```/);
    if (!jsonMatch) {
      jsonMatch = content.match(/\{[\s\S]*\}/);
    }
    
    if (!jsonMatch) {
      throw new Error('Invalid JSON in translation');
    }

    return JSON.parse(jsonMatch[1] || jsonMatch[0]);

  } catch (error) {
    console.error('[ç¿»è¯‘] OpenRouter é”™è¯¯:', error);
    throw error;
  }
}

// ==================== Payload å‘å¸ƒ (ä¿®å¤ç‰ˆ) ====================

async function publishToPayload(env, article, logs) {
  // æ­¥éª¤ 1: å…ˆç™»å½•è·å– Token
  let token = env.PAYLOAD_TOKEN;
  
  if (!token) {
    if (!env.PAYLOAD_EMAIL || !env.PAYLOAD_PASSWORD) {
      logs.push('[Payload] âŒ æœªé…ç½®è®¤è¯ä¿¡æ¯ (éœ€è¦ PAYLOAD_TOKEN æˆ– PAYLOAD_EMAIL + PAYLOAD_PASSWORD)');
      return false;
    }
    
    try {
      logs.push('[Payload] å¼€å§‹ç™»å½•...');
      const loginResponse = await fetch('https://payload-website-starter-blush-sigma.vercel.app/api/users/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: env.PAYLOAD_EMAIL,
          password: env.PAYLOAD_PASSWORD
        })
      });
      
      if (!loginResponse.ok) {
        const errorText = await loginResponse.text();
        logs.push(`[Payload] âŒ ç™»å½•å¤±è´¥: ${errorText}`);
        return false;
      }
      
      const loginData = await loginResponse.json();
      token = loginData.token;
      logs.push('[Payload] âœ… ç™»å½•æˆåŠŸ');
    } catch (error) {
      logs.push(`[Payload] âŒ ç™»å½•é”™è¯¯: ${error.message}`);
      return false;
    }
  } else {
    logs.push('[Payload] ä½¿ç”¨å·²é…ç½®çš„ Token');
  }
  
  // æ­¥éª¤ 2: å‘å¸ƒæ–‡ç« 
  try {
 const payloadData = {
      title: article.title,
      content: {
        root: {
          type: 'root',
          children: [
            {
              type: 'heading',
              children: [{ type: 'text', text: 'ä¸­æ–‡æ‘˜è¦' }],
              tag: 'h2'
            },
            {
              type: 'paragraph',
              children: [{ type: 'text', text: article.summary }]
            },
            {
              type: 'heading',
              children: [{ type: 'text', text: 'English Summary' }],
              tag: 'h2'
            },
            {
              type: 'paragraph',
              children: [{ type: 'text', text: article.translation || article.summary }]
            }
          ]
        }
      },
      slug: generateSlug(article.title),
      publishedAt: new Date().toISOString(),
      _status: 'published',
      meta: {
        title: article.title,
        description: article.summary.substring(0, 160)
      }
    };
    const response = await fetch('https://payload-website-starter-blush-sigma.vercel.app/api/posts', {
      method: 'POST',
      headers: {
        'Authorization': `JWT ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payloadData)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      logs.push(`[Payload] âŒ å‘å¸ƒå¤±è´¥: ${errorText}`);
      return false;
    }
    
    const result = await response.json();
    logs.push(`[Payload] âœ… å‘å¸ƒæˆåŠŸ ID: ${result.doc.id}`);

   // è§¦å‘ Hugo é‡æ–°æ„å»º
    if (env.DEPLOY_HOOK_URL) {
      try {
        const deployResponse = await fetch(env.DEPLOY_HOOK_URL, {
          method: 'POST'
        });
        
        if (deployResponse.ok) {
          logs.push(`[Hugo] âœ… éƒ¨ç½²å·²è§¦å‘`);
        } else {
          const errorText = await deployResponse.text();
          logs.push(`[Hugo] âš ï¸ éƒ¨ç½²å¤±è´¥: ${errorText}`);
        }
      } catch (error) {
        logs.push(`[Hugo] âŒ éƒ¨ç½²é”™è¯¯: ${error.message}`);
      }
    }
    
    
    
    return true;
  } catch (error) {
    logs.push(`[Payload] âŒ å‘å¸ƒå¼‚å¸¸: ${error.message}`);
    return false;
  }
}

// ==================== Telegram é€šçŸ¥ ====================

async function sendBilingualToTelegram(env, article, logs) {
  if (!env.TELEGRAM_BOT_TOKEN || !env.TELEGRAM_CHANNEL) {
    logs.push(`[Telegram] â­ï¸ æœªé…ç½®`);
    return;
  }

  const langLabel = article.language === 'zh' ? 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡' : 'ğŸ‡¬ğŸ‡§ English';
  const message = `ğŸ“° ${langLabel} æ–°æ–‡ç« 

**${article.title}**

${article.summary}

---

**Translation**:
${article.translation}

ğŸ”— ${article.url}`;

  try {
    const response = await fetch(`https://api.telegram.org/bot${env.TELEGRAM_BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: env.TELEGRAM_CHANNEL,
        text: message,
        parse_mode: 'Markdown',
        disable_web_page_preview: false
      })
    });

    if (response.ok) {
      logs.push(`[Telegram] âœ… å·²å‘é€`);
    } else {
      const errorText = await response.text();
      logs.push(`[Telegram] âš ï¸ å¤±è´¥: ${response.status} - ${errorText.substring(0, 100)}`);
    }
  } catch (error) {
    logs.push(`[Telegram] âŒ é”™è¯¯: ${error.message}`);
  }
}

async function sendSummaryToTelegram(env, articles, logs) {
  if (!env.TELEGRAM_BOT_TOKEN || !env.TELEGRAM_CHANNEL) {
    return;
  }

  const articleList = articles.map((a, i) => `${i + 1}. ${a.title}`).join('\n');
  const message = `âœ… æœ¬æ¬¡èšåˆå®Œæˆ

ğŸ“Š å‘å¸ƒäº† ${articles.length} ç¯‡æ–‡ç« :
${articleList}

ğŸŒ æŸ¥çœ‹ç½‘ç«™: https://siji-weekly.pages.dev`;

  try {
    const response = await fetch(`https://api.telegram.org/bot${env.TELEGRAM_BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: env.TELEGRAM_CHANNEL,
        text: message,
        parse_mode: 'Markdown'
      })
    });

    if (response.ok) {
      logs.push(`[Telegram] âœ… æ±‡æ€»å·²å‘é€`);
    }
  } catch (error) {
    logs.push(`[Telegram] âŒ æ±‡æ€»å‘é€å¤±è´¥: ${error.message}`);
  }
}

// ==================== å·¥å…·å‡½æ•° ====================

function extractTag(xml, tagName) {
  const match = xml.match(new RegExp(`<${tagName}[^>]*>([\\s\\S]*?)<\\/${tagName}>`, 'i'));
  if (!match) return '';
  
  let content = match[1].trim();
  content = content.replace(/<!\[CDATA\[([\s\S]*?)\]\]>/g, '$1');
  content = content.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
  content = content.replace(/<[^>]+>/g, '');
  
  return content;
}

function detectLanguage(text) {
  const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
  const totalChars = text.length;
  return (chineseChars / totalChars) > 0.3 ? 'zh' : 'en';
}

function generateSlug(title) {
  // ç”ŸæˆåŸºç¡€ slug
  const baseSlug = title
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .substring(0, 40);
  
  // æ·»åŠ æ—¶é—´æˆ³åç¼€é¿å…é‡å¤
  const timestamp = Date.now().toString(36);
  
  return `${baseSlug}-${timestamp}`;
}