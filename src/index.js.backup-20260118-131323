// ==================== é…ç½®åŒº ====================

const AI_PROVIDERS = {
  OPENROUTER: 'openrouter',
  CLAUDE: 'claude',
  CLAUDE_AGENT: 'claude_agent'
};

const CLAUDE_CONFIG = {
  endpoint: 'https://api.anthropic.com/v1/messages',
  model: 'claude-3-5-sonnet-20241022',
  version: '2023-06-01'
};

const OPENROUTER_CONFIG = {
  endpoint: 'https://openrouter.ai/api/v1/chat/completions',
  models: [
    'anthropic/claude-3.5-sonnet',
    'google/gemini-pro-1.5',
    'deepseek/deepseek-chat',
    'qwen/qwen-2.5-72b-instruct'
  ]
};

const CLAUDE_AGENT_CONFIG = {
  enabled: false,
  endpoint: '',
  features: {
    deepAnalysis: true,
    multiRound: true,
    customPrompts: true
  }
};
// ==================== å»é‡è¾…åŠ©å‡½æ•° ====================

function normalizeUrl(url) {
  try {
    const parsed = new URL(url);
    let normalized = `${parsed.protocol}//${parsed.host}${parsed.pathname}`;
    normalized = normalized.toLowerCase().replace(/\/+$/, '');
    return normalized;
  } catch (error) {
    console.error('[URL] è§£æå¤±è´¥:', url, error.message);
    return url.toLowerCase();
  }
}

function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = ((hash << 5) - hash) + str.charCodeAt(i);
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}

function generateTitleHash(title) {
  const normalized = title
    .toLowerCase()
    .replace(/[^\w\s\u4e00-\u9fa5]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
  return simpleHash(normalized);
}

/**
 * AI ç”Ÿæˆå†…å®¹æŒ‡çº¹
 * ä½¿ç”¨ Claude 3.5 æå–æ–‡ç« æ ¸å¿ƒå…³é”®è¯ï¼Œç”Ÿæˆå†…å®¹æŒ‡çº¹ç”¨äºå»é‡
 */
async function generateContentFingerprint(env, article) {
  try {
    const prompt = `Extract 3-5 core topic keywords from this article. Return ONLY comma-separated keywords in English, lowercase, no extra text.

Title: ${article.title}
Summary: ${article.summary ? article.summary.substring(0, 300) : article.title}

Keywords:`;

    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': 'https://sijigpt.com',
        'X-Title': 'SiJiGPT'
      },
      body: JSON.stringify({
        model: 'anthropic/claude-3.5-sonnet',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 50,
        temperature: 0.3
      })
    });

    if (!response.ok) {
      throw new Error(`OpenRouter API é”™è¯¯: ${response.status}`);
    }

    const data = await response.json();
    const keywords = data.choices[0].message.content.trim().toLowerCase();
    
    // æ’åºå…³é”®è¯ç”ŸæˆæŒ‡çº¹
    const sorted = keywords.split(',')
      .map(k => k.trim())
      .filter(k => k.length > 0)
      .sort()
      .join('-');
    
    return simpleHash(sorted);
  } catch (error) {
    console.error('[Fingerprint] ç”Ÿæˆå¤±è´¥:', error.message);
    // å¤±è´¥æ—¶ä½¿ç”¨æ ‡é¢˜å“ˆå¸Œä½œä¸ºé™çº§æ–¹æ¡ˆ
    return generateTitleHash(article.title);
  }
}

/**
 * ä¸‰å±‚å»é‡æ£€æŸ¥
 * ç¬¬ä¸€å±‚ï¼šURL ç²¾ç¡®åŒ¹é…
 * ç¬¬äºŒå±‚ï¼šæ ‡é¢˜ç›¸ä¼¼åº¦åŒ¹é…
 * ç¬¬ä¸‰å±‚ï¼šå†…å®¹æŒ‡çº¹åŒ¹é…ï¼ˆAI è¾…åŠ©ï¼‰
 */

/**
 * æˆªæ–­æ ‡é¢˜ï¼Œè¶…å‡ºé•¿åº¦æ˜¾ç¤ºçœç•¥å·
 * @param {string} title - åŸæ ‡é¢˜
 * @param {number} maxLength - æœ€å¤§é•¿åº¦ï¼ˆä¸­æ–‡æŒ‰2å­—ç¬¦ï¼Œè‹±æ–‡æŒ‰1å­—ç¬¦è®¡ç®—ï¼‰
 * @returns {string} æˆªæ–­åçš„æ ‡é¢˜
 */
function truncateTitle(title, maxLength = 60) {
  if (!title) return '';
  
  let length = 0;
  let result = '';
  
  // éå†æ¯ä¸ªå­—ç¬¦
  for (const char of title) {
    // ä¸­æ–‡ã€æ—¥æ–‡ã€éŸ©æ–‡å­—ç¬¦ç®— 2 ä¸ªé•¿åº¦ï¼Œè‹±æ–‡ç­‰å…¶ä»–å­—ç¬¦ç®— 1 ä¸ªé•¿åº¦
    const charLength = /[\u4e00-\u9fa5\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af]/.test(char) ? 2 : 1;
    
    // å¦‚æœåŠ ä¸Šå½“å‰å­—ç¬¦ä¼šè¶…å‡ºé•¿åº¦é™åˆ¶ï¼Œåˆ™åœæ­¢å¹¶æ·»åŠ çœç•¥å·
    if (length + charLength > maxLength) {
      return result.trim() + '...';
    }
    
    result += char;
    length += charLength;
  }
  
  return result;
}



async function checkDuplicates(env, article, logs) {
  const normalizedUrl = normalizeUrl(article.link);
  const titleHash = generateTitleHash(article.title);
  
  // ç¬¬ä¸€å±‚ï¼šURL ç²¾ç¡®å»é‡
  const urlKey = `url:${normalizedUrl}`;
  const urlExists = await env.ARTICLES_KV.get(urlKey);
  if (urlExists) {
    logs.push(`[å»é‡] â­ï¸ URL å·²å­˜åœ¨: ${article.link}`);
    return true;
  }
  
  // ç¬¬äºŒå±‚ï¼šæ ‡é¢˜ç›¸ä¼¼åº¦å»é‡
  const titleKey = `title:${titleHash}`;
  const titleExists = await env.ARTICLES_KV.get(titleKey);
  if (titleExists) {
    logs.push(`[å»é‡] â­ï¸ ç›¸ä¼¼æ ‡é¢˜å·²å­˜åœ¨: ${article.title}`);
    return true;
  }
  
  // ç¬¬ä¸‰å±‚ï¼šå†…å®¹æŒ‡çº¹å»é‡ï¼ˆAI è¾…åŠ©ï¼‰
  const fingerprint = await generateContentFingerprint(env, article);
  const fpKey = `fp:${fingerprint}`;
  const fpExists = await env.ARTICLES_KV.get(fpKey);
  if (fpExists) {
    logs.push(`[å»é‡] â­ï¸ ç›¸ä¼¼å†…å®¹å·²å­˜åœ¨: ${article.title}`);
    return true;
  }
  
  return false;
}

/**
 * ä¿å­˜å»é‡è®°å½•
 * åŒæ—¶ä¿å­˜ URLã€æ ‡é¢˜å“ˆå¸Œã€å†…å®¹æŒ‡çº¹ä¸‰ä¸ªé”®
 * TTL è®¾ç½®ä¸º 30 å¤©
 */
async function saveDuplicateKeys(env, article) {
  const normalizedUrl = normalizeUrl(article.link);
  const titleHash = generateTitleHash(article.title);
  const fingerprint = await generateContentFingerprint(env, article);
  
  const ttl = 2592000; // 30 å¤©
  const timestamp = new Date().toISOString();
  
  // ä¿å­˜ä¸‰ä¸ªå»é‡é”®
  await env.ARTICLES_KV.put(`url:${normalizedUrl}`, JSON.stringify({
    publishedAt: timestamp,
    title: article.title
  }), { expirationTtl: ttl });
  
  await env.ARTICLES_KV.put(`title:${titleHash}`, JSON.stringify({
    publishedAt: timestamp,
    title: article.title
  }), { expirationTtl: ttl });
  
  await env.ARTICLES_KV.put(`fp:${fingerprint}`, JSON.stringify({
    publishedAt: timestamp,
    title: article.title
  }), { expirationTtl: ttl });
}

/**
 * ä» URL æå–æ¥æºåç§°
 * ä¾‹å¦‚ï¼šhttps://openai.com/blog/article â†’ OpenAI Blog
 */
function extractSourceName(url) {
  try {
    const parsed = new URL(url);
    const hostname = parsed.hostname.replace("www.", "");
    
    const sourceMap = {
      "openai.com": "OpenAI Blog",
      "anthropic.com": "Anthropic News",
      "blog.google": "Google AI Blog",
      "deepmind.com": "DeepMind Blog",
      "deepmind.google": "DeepMind Blog",
      "ai.meta.com": "Meta AI Blog",
      "microsoft.com": "Microsoft Research",
      "huggingface.co": "Hugging Face Blog",
      "aws.amazon.com": "AWS Machine Learning Blog",
      "blog.langchain.dev": "LangChain Blog",
      "lilianweng.github.io": "Lil'Log",
      "karpathy.github.io": "Andrej Karpathy Blog",
      "distill.pub": "Distill",
      "arxiv.org": "arXiv",
      "news.ycombinator.com": "Hacker News"
    };
    
    for (const [domain, name] of Object.entries(sourceMap)) {
      if (hostname.includes(domain)) {
        return name;
      }
    }
    
    return hostname.split(".")[0].charAt(0).toUpperCase() + hostname.split(".")[0].slice(1);
  } catch (error) {
    return "Unknown Source";
  }
}

// ==================== ä¸»å…¥å£ ====================

export default {
  async scheduled(event, env, ctx) {
    console.log('[å®šæ—¶ä»»åŠ¡] è§¦å‘æ—¶é—´:', new Date().toISOString());
    try {
      const result = await aggregateArticles(env);
      console.log('[å®šæ—¶ä»»åŠ¡] å®Œæˆ:', JSON.stringify(result));
    } catch (error) {
      console.error('[å®šæ—¶ä»»åŠ¡] é”™è¯¯:', error);
    }
  },

  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;

    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization'
        }
      });
    }

    if (path === '/health' || path === '/') {
      return new Response(JSON.stringify({
        status: 'ok',
        service: 'Siji Worker V2',
        provider: env.AI_PROVIDER || 'openrouter',
        timestamp: new Date().toISOString(),
        version: '2.0.1'
      }), {
        headers: { 
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*'
        }
      });
    }

    if (path === '/test' && request.method === 'POST') {
      try {
        const result = await aggregateArticles(env);
        return new Response(JSON.stringify(result), {
          headers: { 
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
          }
        });
      } catch (error) {
        return new Response(JSON.stringify({ 
          error: error.message,
          stack: error.stack 
        }), {
          status: 500,
          headers: { 
            'Content-Type': 'application/json',
            'Access-Control-Allow-Origin': '*'
          }
        });
      }
    }

    return new Response('Siji Worker V2 Running', { 
      status: 404,
      headers: { 'Access-Control-Allow-Origin': '*' }
    });
  }
};

// ==================== æ ¸å¿ƒèšåˆé€»è¾‘ ====================

async function aggregateArticles(env) {
  const logs = [];
  let count = 0;
  let published = 0;
  const publishedArticles = [];
  
  const rssFeeds = (env.RSS_FEEDS || '').split(',')
    .map(s => s.trim())
    .filter(Boolean)
    .slice(0, 15);
  
  const dailyTarget = parseInt(env.DAILY_TARGET || '20', 10);
  
  logs.push(`[å¼€å§‹] ç›®æ ‡: ${dailyTarget} ç¯‡, RSS æº: ${rssFeeds.length} ä¸ª`);
  logs.push(`[AI] ä½¿ç”¨: ${env.AI_PROVIDER || 'openrouter'}`);

  for (const feedUrl of rssFeeds) {
    if (published >= dailyTarget) {
      logs.push(`[å®Œæˆ] å·²è¾¾ç›®æ ‡ ${dailyTarget} ç¯‡ï¼Œåœæ­¢æŠ“å–`);
      break;
    }
    
    logs.push(`[RSS] æŠ“å–: ${feedUrl}`);
    
    try {
      const response = await fetch(feedUrl, { 
        signal: AbortSignal.timeout(10000),
        headers: { 'User-Agent': 'Siji-Worker/2.0' }
      });
      
      if (!response.ok) {
        logs.push(`[RSS] âŒ HTTP ${response.status}`);
        continue;
      }
      
      const xmlText = await response.text();
      
      const itemMatch = xmlText.match(/<item[^>]*>([\s\S]*?)<\/item>/i);
      if (!itemMatch) {
        logs.push(`[RSS] âš ï¸ æœªæ‰¾åˆ°æ–‡ç« `);
        continue;
      }
      
      const itemContent = itemMatch[1];
      const title = extractTag(itemContent, 'title');
      const link = extractTag(itemContent, 'link');
      const description = extractTag(itemContent, 'description');
      
      if (!title || !link) {
        logs.push(`[RSS] âš ï¸ æ–‡ç« ä¿¡æ¯ä¸å®Œæ•´`);
        continue;
      }
      
      count++;
      logs.push(`[RSS] æ‰¾åˆ°: ${title.substring(0, 50)}...`);
      
      
      // ä¸‰å±‚å»é‡æ£€æŸ¥
      const article = { link, title, summary: description };
      const isDuplicate = await checkDuplicates(env, article, logs);
      if (isDuplicate) {
        continue;
      }
      
      // AI åˆ¤å®šä¸åŒè¯­å†…å®¹ç”Ÿæˆ
      const aiData = await callAI(env, title, description);
      
      if (!aiData || !aiData.relevant) {
        logs.push(`[AI] â­ï¸ ä¸ç›¸å…³`);
        continue;
      }
      
      // æ–°çš„æ•°æ®ç»“æ„ï¼šAI å·²è¿”å›å®Œæ•´åŒè¯­å†…å®¹
      const originalLang = aiData.original_language || "en";
      logs.push(`[AI] âœ… ç›¸å…³, åŸæ–‡è¯­è¨€: ${originalLang}`);
      logs.push(`[å†…å®¹] ä¸­æ–‡æ‘˜è¦: ${aiData.summary_zh.length} å­—, è‹±æ–‡æ‘˜è¦: ${aiData.summary_en.length} å­—`);
      
      // ç¡®å®šæœ€ç»ˆæ ‡é¢˜ï¼ˆå§‹ç»ˆä½¿ç”¨ä¸­æ–‡æ ‡é¢˜ï¼‰
      const finalTitle = aiData.title_zh;
      const finalTitleEn = aiData.title_en;
      
      // æ„å»ºåŒè¯­å†…å®¹ï¼ˆæŒ‰éœ€æ±‚ 2 çš„æ ¼å¼ï¼‰
    // ============================================
      // æ„å»ºåŒè¯­å†…å®¹ï¼ˆHTML æ ¼å¼ï¼Œè§£å†³æ˜Ÿå·æ˜¾ç¤ºé—®é¢˜ï¼‰
      // ============================================
      
      // ============================================
      // æ„å»ºåŒè¯­å†…å®¹ï¼ˆç®€åŒ–æ¥æºæ ¼å¼ï¼Œå®Œæ•´æ ‡é¢˜è‡ªåŠ¨æ¢è¡Œï¼‰
      // ============================================
      
      // å‡†å¤‡åŸæ–‡æ ‡é¢˜æ•°æ®
      const fullTitle = finalTitleEn || finalTitle; // å®Œæ•´åŸæ–‡æ ‡é¢˜
      
      // æ„å»º HTML æ ¼å¼çš„åŒè¯­å†…å®¹
      const bilingualContent = `
<p><strong>æ¥æºï¼š</strong><a href="${link}" target="_blank" rel="noopener noreferrer">${fullTitle}</a></p>

---

<h2><strong>ä¸­æ–‡æ‘˜è¦</strong></h2>

${aiData.summary_zh}

<p><strong>å…³é”®è¯ï¼š</strong>${(aiData.keywords_zh || []).join("ã€")}</p>

---

<h2><strong>English Summary</strong></h2>

<p><strong>${finalTitleEn}</strong></p>

${aiData.summary_en}

<p><strong>Keywords:</strong> ${(aiData.keywords_en || []).join(", ")}</p>
`.trim();
      // æ„å»º Payload æ•°æ®å¯¹è±¡
      const payloadData = {
        title: finalTitle,
        title_en: finalTitleEn,
        source: {
          url: link,
          name: extractSourceName(link)
        },
        summary_zh: {
          content: aiData.summary_zh,
          keywords: (aiData.keywords_zh || []).map(kw => ({ keyword: kw }))
        },
        summary_en: {
          content: aiData.summary_en,
          keywords: (aiData.keywords_en || []).map(kw => ({ keyword: kw }))
        },
        original_language: aiData.original_language || 'en',
        content: bilingualContent
      };

      const payloadSuccess = await publishToPayload(env, payloadData, logs);
      
      if (!payloadSuccess) {
        logs.push(`[Payload] âŒ å‘å¸ƒå¤±è´¥`);
        continue;
      }
      
      // å‘é€ Telegram é€šçŸ¥
      await sendBilingualToTelegram(env, {
        title: finalTitle,
        url: link,
        summary: aiData.summary_zh.substring(0, 150),
        translation: aiData.summary_en.substring(0, 150),
        language: originalLang
      }, logs);
      
      // ä¿å­˜ä¸‰å±‚å»é‡è®°å½•ï¼ˆ30å¤© TTLï¼‰
      await saveDuplicateKeys(env, {
        link,
        title: finalTitle,
        summary: aiData.summary
      });
      
      published++;
      publishedArticles.push({ title: finalTitle, url: link });
      logs.push(`[å‘å¸ƒ] âœ… æˆåŠŸ (${published}/${dailyTarget})`);
      
    } catch (error) {
      logs.push(`[é”™è¯¯] ${feedUrl}: ${error.message}`);
    }
  }
  
  logs.push(`[å®Œæˆ] å¤„ç†: ${count}, å‘å¸ƒ: ${published}`);
  
  if (published > 0) {
    await sendSummaryToTelegram(env, publishedArticles, logs);
  }
  
  if (published > 0 && env.DEPLOY_HOOK_URL) {
    logs.push(`[Hugo] è§¦å‘éƒ¨ç½²...`);
    try {
      const deployResponse = await fetch(env.DEPLOY_HOOK_URL, { 
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (deployResponse.ok) {
        logs.push(`[Hugo] âœ… éƒ¨ç½²å·²è§¦å‘`);
      } else {
        logs.push(`[Hugo] âš ï¸ éƒ¨ç½²è§¦å‘å¤±è´¥: ${deployResponse.status}`);
      }
    } catch (error) {
      logs.push(`[Hugo] âŒ éƒ¨ç½²é”™è¯¯: ${error.message}`);
    }
  }
  
  return { 
    count, 
    published, 
    provider: env.AI_PROVIDER || 'openrouter', 
    logs 
  };
}

// ==================== AI è°ƒç”¨ ====================

function getAIProvider(env) {
  const provider = (env.AI_PROVIDER || 'openrouter').toLowerCase();
  
  if (provider === 'claude' && env.CLAUDE_API_KEY) {
    return AI_PROVIDERS.CLAUDE;
  }
  
  if (provider === 'claude_agent' && CLAUDE_AGENT_CONFIG.enabled) {
    return AI_PROVIDERS.CLAUDE_AGENT;
  }
  
  return AI_PROVIDERS.OPENROUTER;
}

async function callAI(env, title, description) {
  const provider = getAIProvider(env);
  
  try {
    if (provider === AI_PROVIDERS.CLAUDE) {
      return await callClaudeAI(env, title, description);
    } else if (provider === AI_PROVIDERS.CLAUDE_AGENT) {
      return await callClaudeAgent(env, title, description);
    } else {
      return await callOpenRouterAI(env, title, description);
    }
  } catch (error) {
    console.error(`[AI] ${provider} å¤±è´¥:`, error);
    
    if (provider === AI_PROVIDERS.CLAUDE && env.OPENROUTER_API_KEY) {
      console.log('[AI] å›é€€åˆ° OpenRouter');
      try {
        return await callOpenRouterAI(env, title, description);
      } catch (fallbackError) {
        console.error('[AI] OpenRouter å›é€€å¤±è´¥:', fallbackError);
      }
    }
    
    return null;
  }
}

async function callClaudeAI(env, title, description) {
  const prompt = `åˆ¤æ–­ä»¥ä¸‹å†…å®¹æ˜¯å¦ä¸äººå·¥æ™ºèƒ½é¢†åŸŸç›¸å…³ã€‚

æ ‡é¢˜: ${title}
æè¿°: ${description}

ç›¸å…³èŒƒå›´åŒ…æ‹¬ä½†ä¸é™äº:
- AI/ML/DL æŠ€æœ¯: æœºå™¨å­¦ä¹ ã€æ·±åº¦å­¦ä¹ ã€å¤§è¯­è¨€æ¨¡å‹ã€è®¡ç®—æœºè§†è§‰ã€NLPã€å¼ºåŒ–å­¦ä¹ 
- AI åº”ç”¨: ChatGPTã€Geminiã€Claudeã€Stable Diffusionã€Midjourneyã€è§†é¢‘ç”Ÿæˆ(Sora/Veo)
- AI ç¡¬ä»¶: GPUã€TPUã€NPUã€AI èŠ¯ç‰‡ã€ç®—åŠ›ã€æ•°æ®ä¸­å¿ƒ
- AI å¹³å°/å·¥å…·: TensorFlowã€PyTorchã€Hugging Faceã€LangChainã€å‘é‡æ•°æ®åº“
- AI å…¬å¸åŠ¨æ€: OpenAIã€Google DeepMindã€Anthropicã€Meta AIã€NVIDIAã€å¾®è½¯ã€äºšé©¬é€Šç­‰çš„ AI ç›¸å…³å‘å¸ƒ
- AI ç ”ç©¶: è®ºæ–‡ã€æ¨¡å‹æ¶æ„ã€è®­ç»ƒæ–¹æ³•ã€è¯„æµ‹åŸºå‡†
- AI ä¼¦ç†/å®‰å…¨: AI å¯¹é½ã€å®‰å…¨æ€§ã€ç›‘ç®¡æ”¿ç­–

è¦æ±‚:
1. å¦‚æœç›¸å…³,è¯·ç”Ÿæˆçº¦300å­—çš„ä¸­æ–‡æ‘˜è¦,ä¿ç•™å…³é”®ä¿¡æ¯å’ŒæŠ€æœ¯è¦ç‚¹
2. å¦‚æœå®Œå…¨ä¸ç›¸å…³(å¦‚çº¯ç²¹çš„æ”¿æ²»ã€ä½“è‚²ã€å¨±ä¹æ–°é—»),è¿”å› relevant: false
3. æå–3-5ä¸ªå…³é”®è¯

**é‡è¦**: å¿…é¡»ä¸¥æ ¼è¿”å›çº¯ JSON,ä¸è¦æœ‰å…¶ä»–æ–‡å­—:
{
  "relevant": true,
  "summary": "çº¦300å­—çš„ä¸­æ–‡æ‘˜è¦",
  "keywords": ["å…³é”®è¯1", "å…³é”®è¯2", "å…³é”®è¯3"]
}`;

  const response = await fetch(CLAUDE_CONFIG.endpoint, {
    method: 'POST',
    headers: {
      'x-api-key': env.CLAUDE_API_KEY,
      'anthropic-version': CLAUDE_CONFIG.version,
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      model: CLAUDE_CONFIG.model,
      max_tokens: 1024,
      temperature: 0.3,
      messages: [{ role: 'user', content: prompt }]
    })
  });

  if (!response.ok) {
    throw new Error(`Claude API error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.content[0]?.text;
  
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Invalid JSON in Claude response');
  }

  return JSON.parse(jsonMatch[0]);
}

async function callOpenRouterAI(env, title, description) {
  const prompt = `åˆ¤æ–­ä»¥ä¸‹å†…å®¹æ˜¯å¦ä¸äººå·¥æ™ºèƒ½é¢†åŸŸç›¸å…³ï¼Œå¹¶ç”Ÿæˆå®Œæ•´çš„åŒè¯­æ‘˜è¦ã€‚

æ ‡é¢˜: ${title}
æè¿°: ${description}

ç›¸å…³èŒƒå›´åŒ…æ‹¬ä½†ä¸é™äº:
- AI/ML/DL æŠ€æœ¯: æœºå™¨å­¦ä¹ ã€æ·±åº¦å­¦ä¹ ã€å¤§è¯­è¨€æ¨¡å‹ã€è®¡ç®—æœºè§†è§‰ã€NLPã€å¼ºåŒ–å­¦ä¹ 
- AI åº”ç”¨: ChatGPTã€Geminiã€Claudeã€Stable Diffusionã€Midjourneyã€è§†é¢‘ç”Ÿæˆ(Sora/Veo)
- AI ç¡¬ä»¶: GPUã€TPUã€NPUã€AI èŠ¯ç‰‡ã€ç®—åŠ›ã€æ•°æ®ä¸­å¿ƒ
- AI å¹³å°/å·¥å…·: TensorFlowã€PyTorchã€Hugging Faceã€LangChainã€å‘é‡æ•°æ®åº“
- AI å…¬å¸åŠ¨æ€: OpenAIã€Google DeepMindã€Anthropicã€Meta AIã€NVIDIAã€å¾®è½¯ã€äºšé©¬é€Šç­‰çš„ AI ç›¸å…³å‘å¸ƒ
- AI ç ”ç©¶: è®ºæ–‡ã€æ¨¡å‹æ¶æ„ã€è®­ç»ƒæ–¹æ³•ã€è¯„æµ‹åŸºå‡†
- AI ä¼¦ç†/å®‰å…¨: AI å¯¹é½ã€å®‰å…¨æ€§ã€ç›‘ç®¡æ”¿ç­–

è¦æ±‚:
1. æ£€æµ‹åŸæ–‡è¯­è¨€ï¼ˆä¸­æ–‡æˆ–è‹±æ–‡ï¼‰
2. å¦‚æœåŸæ–‡æ˜¯è‹±æ–‡ï¼šç”Ÿæˆä¸­æ–‡æ ‡é¢˜ã€ä¸­æ–‡æ‘˜è¦ï¼ˆ300å­—ï¼‰ã€è‹±æ–‡æ‘˜è¦ï¼ˆ300å­—ï¼‰
3. å¦‚æœåŸæ–‡æ˜¯ä¸­æ–‡ï¼šä¿æŒä¸­æ–‡æ ‡é¢˜ã€ç”Ÿæˆä¸­æ–‡æ‘˜è¦ï¼ˆ300å­—ï¼‰ã€ç¿»è¯‘è‹±æ–‡æ ‡é¢˜å’Œè‹±æ–‡æ‘˜è¦ï¼ˆ300å­—ï¼‰
4. æå– 3-5 ä¸ªä¸­æ–‡å…³é”®è¯å’Œ 3-5 ä¸ªè‹±æ–‡å…³é”®è¯
5. å¦‚æœå®Œå…¨ä¸ç›¸å…³ï¼Œè¿”å› relevant: false

**é‡è¦**: å¿…é¡»ä¸¥æ ¼è¿”å›çº¯ JSON:
{
  "relevant": true,
  "original_language": "en",
  "title_zh": "ä¸­æ–‡æ ‡é¢˜",
  "title_en": "English Title",
  "summary_zh": "çº¦300å­—çš„ä¸­æ–‡æ‘˜è¦",
  "summary_en": "Approximately 300-word English summary",
  "keywords_zh": ["å…³é”®è¯1", "å…³é”®è¯2", "å…³é”®è¯3"],
  "keywords_en": ["keyword1", "keyword2", "keyword3"]
}`;

  const models = OPENROUTER_CONFIG.models || ['anthropic/claude-3.5-sonnet'];
  
  for (let i = 0; i < models.length; i++) {
    const model = models[i];
    try {
      console.log(`[AI] å°è¯•æ¨¡å‹ ${i + 1}/${models.length}: ${model}`);
      
      const response = await fetch(OPENROUTER_CONFIG.endpoint, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${env.OPENROUTER_API_KEY}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'https://sijigpt.com',
          'X-Title': 'SijiGPT'
        },
        body: JSON.stringify({
          model: model,
          messages: [{ role: 'user', content: prompt }],
          temperature: 0.3,
          max_tokens: 1500
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[AI] æ¨¡å‹ ${model} å¤±è´¥ ${response.status}:`, errorText.substring(0, 100));
        if (i < models.length - 1) {
          console.log(`[AI] â­ï¸ åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ¨¡å‹...`);
          continue;
        }
        throw new Error(`æ‰€æœ‰æ¨¡å‹éƒ½å¤±è´¥äº†`);
      }

      const data = await response.json();
      const content = data.choices?.[0]?.message?.content;
      
      if (!content) {
        console.error(`[AI] æ¨¡å‹ ${model} è¿”å›ç©ºå†…å®¹`);
        if (i < models.length - 1) continue;
        throw new Error('AIè¿”å›ç©ºå†…å®¹');
      }

      const cleanedContent = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
      const result = JSON.parse(cleanedContent);
      
      console.log(`[AI] âœ… æ¨¡å‹ ${model} æˆåŠŸ`);
      return result;

    } catch (error) {
      console.error(`[AI] æ¨¡å‹ ${model} é”™è¯¯:`, error.message);
      if (i < models.length - 1) {
        console.log(`[AI] â­ï¸ åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ¨¡å‹...`);
        continue;
      }
      throw error;
    }
  }
}


async function callClaudeAgent(env, title, description) {
  console.log('[AI] Claude Agent æš‚æœªå¯ç”¨ï¼Œå›é€€åˆ° OpenRouter');
  return await callOpenRouterAI(env, title, description);
}

// ==================== ç¿»è¯‘å‡½æ•° ====================

async function translateText(env, text, title, fromLang) {
  const provider = getAIProvider(env);
  
  try {
    if (provider === AI_PROVIDERS.CLAUDE) {
      return await translateWithClaude(env, text, title, fromLang);
    } else {
      return await translateWithOpenRouter(env, text, title, fromLang);
    }
  } catch (error) {
    console.error(`[ç¿»è¯‘] ${provider} å¤±è´¥:`, error);
    
    if (provider === AI_PROVIDERS.CLAUDE && env.OPENROUTER_API_KEY) {
      console.log('[ç¿»è¯‘] å›é€€åˆ° OpenRouter');
      try {
        return await translateWithOpenRouter(env, text, title, fromLang);
      } catch (fallbackError) {
        console.error('[ç¿»è¯‘] OpenRouter å›é€€å¤±è´¥:', fallbackError);
      }
    }
    
    return null;
  }
}

async function translateWithClaude(env, text, title, fromLang) {
  const toLang = fromLang === 'zh' ? 'English' : 'ä¸­æ–‡';
  const prompt = `è¯·å°†ä»¥ä¸‹å†…å®¹ç¿»è¯‘æˆ${toLang}ï¼Œä¿ç•™çº¦300å­—é•¿åº¦ï¼š

æ ‡é¢˜: ${title}
å†…å®¹: ${text}

è¿”å›çº¯ JSON æ ¼å¼:
{
  "title": "ç¿»è¯‘åçš„æ ‡é¢˜",
  "content": "ç¿»è¯‘åçš„å†…å®¹ï¼ˆçº¦300å­—ï¼‰"
}`;

  const response = await fetch(CLAUDE_CONFIG.endpoint, {
    method: 'POST',
    headers: {
      'x-api-key': env.CLAUDE_API_KEY,
      'anthropic-version': CLAUDE_CONFIG.version,
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      model: CLAUDE_CONFIG.model,
      max_tokens: 1024,
      temperature: 0.3,
      messages: [{ role: 'user', content: prompt }]
    })
  });

  if (!response.ok) {
    throw new Error(`Claude translation error: ${response.status}`);
  }

  const data = await response.json();
  const content = data.content[0]?.text;
  
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Invalid JSON');
  }

  return JSON.parse(jsonMatch[0]);
}

async function translateWithOpenRouter(env, text, title, fromLang) {
  const toLang = fromLang === 'zh' ? 'English' : 'ä¸­æ–‡';
  const prompt = `è¯·å°†ä»¥ä¸‹å†…å®¹ç¿»è¯‘æˆ${toLang}ï¼Œä¿ç•™çº¦300å­—é•¿åº¦ï¼š

æ ‡é¢˜: ${title}
å†…å®¹: ${text}

è¿”å›çº¯ JSON æ ¼å¼:
{
  "title": "ç¿»è¯‘åçš„æ ‡é¢˜",
  "content": "ç¿»è¯‘åçš„å†…å®¹ï¼ˆçº¦300å­—ï¼‰"
}`;

  try {
    const response = await fetch(OPENROUTER_CONFIG.endpoint, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENROUTER_API_KEY}`,
        'Content-Type': 'application/json',
        'HTTP-Referer': 'https://siji-weekly.pages.dev',
        'X-Title': 'Siji Weekly'
      },
      body: JSON.stringify({
        model: OPENROUTER_CONFIG.model,
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.3,
        max_tokens: 1000
      })
    });

    if (!response.ok) {
      throw new Error(`OpenRouter translation error: ${response.status}`);
    }

    const responseText = await response.text();
    const data = JSON.parse(responseText);
    const content = data.choices[0]?.message?.content;
    
    let jsonMatch = content.match(/```json\s*(\{[\s\S]*?\})\s*```/);
    if (!jsonMatch) {
      jsonMatch = content.match(/\{[\s\S]*\}/);
    }
    
    if (!jsonMatch) {
      throw new Error('Invalid JSON in translation');
    }

    return JSON.parse(jsonMatch[1] || jsonMatch[0]);

  } catch (error) {
    console.error('[ç¿»è¯‘] OpenRouter é”™è¯¯:', error);
    throw error;
  }
}

// ==================== Payload å‘å¸ƒ (ä¿®å¤ç‰ˆ) ====================

async function publishToPayload(env, article, logs) {
  // æ­¥éª¤ 1: å…ˆç™»å½•è·å– Token
  let token = env.PAYLOAD_TOKEN;
  
  if (!token) {
    if (!env.PAYLOAD_EMAIL || !env.PAYLOAD_PASSWORD) {
      logs.push('[Payload] âŒ æœªé…ç½®è®¤è¯ä¿¡æ¯ (éœ€è¦ PAYLOAD_TOKEN æˆ– PAYLOAD_EMAIL + PAYLOAD_PASSWORD)');
      return false;
    }
    
    try {
      logs.push('[Payload] å¼€å§‹ç™»å½•...');
      const loginResponse = await fetch('https://payload-website-starter-blush-sigma.vercel.app/api/users/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: env.PAYLOAD_EMAIL,
          password: env.PAYLOAD_PASSWORD
        })
      });
      
      if (!loginResponse.ok) {
        const errorText = await loginResponse.text();
        logs.push(`[Payload] âŒ ç™»å½•å¤±è´¥: ${errorText}`);
        return false;
      }
      
      const loginData = await loginResponse.json();
      token = loginData.token;
      logs.push('[Payload] âœ… ç™»å½•æˆåŠŸ');
    } catch (error) {
      logs.push(`[Payload] âŒ ç™»å½•é”™è¯¯: ${error.message}`);
      return false;
    }
  } else {
    logs.push('[Payload] ä½¿ç”¨å·²é…ç½®çš„ Token');
  }
  
  // æ­¥éª¤ 2: å‘å¸ƒæ–‡ç« 
  try {
     // æ„å»º Payload æ•°æ®ï¼ˆåŒè¯­æ ¼å¼ï¼‰
    const payloadData = {
      title: article.title,
      title_en: article.title_en || article.title,
      source_url: article.source_url || article.url,
      source_name: article.source_name || "Unknown Source",
      original_language: article.original_language || "en",
      content: {
        root: {
          type: "root",
          children: [
                        // æ¥æºä¿¡æ¯
            {
              type: "paragraph",
              children: [
                { type: "text", text: "æ¥æºï¼š", bold: true },
                { type: "text", text: article.source_name || "Unknown Source" },
                { type: "text", text: " (" },
                { type: "text", text: article.source_url || article.url || "" },
                { type: "text", text: ")" }
              ]
            },
            // åˆ†éš”çº¿ï¼ˆç”¨ç©ºæ®µè½ä»£æ›¿ï¼‰
            {
              type: "paragraph",
              children: [{ type: "text", text: "---" }]
            },
            // ä¸­æ–‡æ‘˜è¦æ ‡é¢˜
            {
              type: "heading",
              children: [{ type: "text", text: "ä¸­æ–‡æ‘˜è¦", bold: true }],
              tag: "h2"
            },
            // ä¸­æ–‡æ‘˜è¦å†…å®¹
            {
              type: "paragraph",
              children: [{ type: "text", text: article.summary_zh || article.summary || "" }]
            },
            // ä¸­æ–‡å…³é”®è¯
            {
              type: "paragraph",
              children: [
                { type: "text", text: "å…³é”®è¯ï¼š", bold: true },
                { type: "text", text: (article.keywords_zh || []).join("ã€") }
              ]
            },
            // åˆ†éš”çº¿
            {
              type: "paragraph",
              children: [{ type: "text", text: "---" }]
            },
            // è‹±æ–‡æ‘˜è¦æ ‡é¢˜
            {
              type: "heading",
              children: [{ type: "text", text: "English Summary", bold: true }],
              tag: "h2"
            },
            // è‹±æ–‡æ ‡é¢˜ï¼ˆåŠ ç²—ï¼Œå•ç‹¬æ®µè½ï¼‰
            {
              type: "paragraph",
              children: [{ type: "text", text: article.title_en || article.title, bold: true }]
            },
            // è‹±æ–‡æ‘˜è¦å†…å®¹
            {
              type: "paragraph",
              children: [{ type: "text", text: article.summary_en || article.translation || article.summary || "" }]
            },
            // è‹±æ–‡å…³é”®è¯
            {
              type: "paragraph",
              children: [
                { type: "text", text: "Keywords: ", bold: true },
                { type: "text", text: (article.keywords_en || []).join(", ") }
              ]
            }
          ]
        }
      },
      slug: generateSlug(article.title),
      publishedAt: new Date().toISOString(),
      _status: "published",
      meta: {
        title: article.title,
        description: (article.summary_zh || article.summary || "").substring(0, 160)
      }
    };
    const response = await fetch('https://payload-website-starter-blush-sigma.vercel.app/api/posts', {
      method: 'POST',
      headers: {
        'Authorization': `JWT ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payloadData)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      logs.push(`[Payload] âŒ å‘å¸ƒå¤±è´¥: ${errorText}`);
      return false;
    }
    
    const result = await response.json();
    logs.push(`[Payload] âœ… å‘å¸ƒæˆåŠŸ ID: ${result.doc.id}`);

   // è§¦å‘ Hugo é‡æ–°æ„å»º
    if (env.DEPLOY_HOOK_URL) {
      try {
        const deployResponse = await fetch(env.DEPLOY_HOOK_URL, {
          method: 'POST'
        });
        
        if (deployResponse.ok) {
          logs.push(`[Hugo] âœ… éƒ¨ç½²å·²è§¦å‘`);
        } else {
          const errorText = await deployResponse.text();
          logs.push(`[Hugo] âš ï¸ éƒ¨ç½²å¤±è´¥: ${errorText}`);
        }
      } catch (error) {
        logs.push(`[Hugo] âŒ éƒ¨ç½²é”™è¯¯: ${error.message}`);
      }
    }
    
    
    
    return true;
  } catch (error) {
    logs.push(`[Payload] âŒ å‘å¸ƒå¼‚å¸¸: ${error.message}`);
    return false;
  }
}

// ==================== Telegram é€šçŸ¥ ====================

async function sendBilingualToTelegram(env, article, logs) {
  if (!env.TELEGRAM_BOT_TOKEN || !env.TELEGRAM_CHANNEL) {
    logs.push(`[Telegram] â­ï¸ æœªé…ç½®`);
    return;
  }

  const langLabel = article.language === 'zh' ? 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡' : 'ğŸ‡¬ğŸ‡§ English';
  const message = `ğŸ“° ${langLabel} æ–°æ–‡ç« 

**${article.title}**

${article.summary}

---

**Translation**:
${article.translation}

ğŸ”— ${article.url}`;

  try {
    const response = await fetch(`https://api.telegram.org/bot${env.TELEGRAM_BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: env.TELEGRAM_CHANNEL,
        text: message,
        parse_mode: 'Markdown',
        disable_web_page_preview: false
      })
    });

    if (response.ok) {
      logs.push(`[Telegram] âœ… å·²å‘é€`);
    } else {
      const errorText = await response.text();
      logs.push(`[Telegram] âš ï¸ å¤±è´¥: ${response.status} - ${errorText.substring(0, 100)}`);
    }
  } catch (error) {
    logs.push(`[Telegram] âŒ é”™è¯¯: ${error.message}`);
  }
}

async function sendSummaryToTelegram(env, articles, logs) {
  if (!env.TELEGRAM_BOT_TOKEN || !env.TELEGRAM_CHANNEL) {
    return;
  }

  const articleList = articles.map((a, i) => `${i + 1}. ${a.title}`).join('\n');
  const message = `âœ… æœ¬æ¬¡èšåˆå®Œæˆ

ğŸ“Š å‘å¸ƒäº† ${articles.length} ç¯‡æ–‡ç« :
${articleList}

ğŸŒ æŸ¥çœ‹ç½‘ç«™: https://siji-weekly.pages.dev`;

  try {
    const response = await fetch(`https://api.telegram.org/bot${env.TELEGRAM_BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: env.TELEGRAM_CHANNEL,
        text: message,
        parse_mode: 'Markdown'
      })
    });

    if (response.ok) {
      logs.push(`[Telegram] âœ… æ±‡æ€»å·²å‘é€`);
    }
  } catch (error) {
    logs.push(`[Telegram] âŒ æ±‡æ€»å‘é€å¤±è´¥: ${error.message}`);
  }
}

// ==================== å·¥å…·å‡½æ•° ====================

function extractTag(xml, tagName) {
  const match = xml.match(new RegExp(`<${tagName}[^>]*>([\\s\\S]*?)<\\/${tagName}>`, 'i'));
  if (!match) return '';
  
  let content = match[1].trim();
  content = content.replace(/<!\[CDATA\[([\s\S]*?)\]\]>/g, '$1');
  content = content.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
  content = content.replace(/<[^>]+>/g, '');
  
  return content;
}

function detectLanguage(text) {
  const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
  const totalChars = text.length;
  return (chineseChars / totalChars) > 0.3 ? 'zh' : 'en';
}

function generateSlug(title) {
  // ç”ŸæˆåŸºç¡€ slug
  const baseSlug = title
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .substring(0, 40);
  
  // æ·»åŠ æ—¶é—´æˆ³åç¼€é¿å…é‡å¤
  const timestamp = Date.now().toString(36);
  
  return `${baseSlug}-${timestamp}`;
}